#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def wakeUpDevice(self, ):
    pass

  def unregisterAlarmer(self, ):
    pass

  def send_mms(self, smsto, content):
    """
    Parameters:
     - smsto
     - content
    """
    pass

  def mt_trigger_service(self, map_trigger):
    """
    Parameters:
     - map_trigger
    """
    pass

  def get_postion(self, ):
    pass

  def get_speed(self, ):
    pass

  def get_battery_temperate(self, unit):
    """
    Parameters:
     - unit
    """
    pass

  def get_orientation(self, ):
    pass

  def get_available_ram(self, ):
    pass

  def get_available_rom(self, ):
    pass

  def get_wifi_rssi(self, ):
    pass

  def get_sim_card_state(self, slotId):
    """
    Parameters:
     - slotId
    """
    pass

  def get_sim_card_rssi(self, slotId):
    """
    Parameters:
     - slotId
    """
    pass

  def get_sim_card_vendor(self, slotId):
    """
    Parameters:
     - slotId
    """
    pass

  def is_bluetooth_enabled(self, ):
    pass

  def is_wifi_enabled(self, ):
    pass

  def get_networktype(self, slotId):
    """
    Parameters:
     - slotId
    """
    pass

  def update_notificationbar(self, text):
    """
    Parameters:
     - text
    """
    pass

  def interactWithUserBySingleBtn(self, title, msg, send_to, send_msg, enable_ring_shake, wait_timeout):
    """
    Parameters:
     - title
     - msg
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
    """
    pass

  def interactWithUserByMultiBtn(self, title, msg, btns, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    """
    Parameters:
     - title
     - msg
     - btns
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
     - default_result
    """
    pass

  def interactWithUserByList(self, title, msg, value, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    """
    Parameters:
     - title
     - msg
     - value
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
     - default_result
    """
    pass

  def goToSleepMode(self, interval):
    """
    Parameters:
     - interval
    """
    pass

  def get_value_from_client(self, name, value):
    """
    Parameters:
     - name
     - value
    """
    pass

  def getBluetoothName(self, ):
    pass

  def getSerialNum(self, ):
    pass

  def disable_watcher_anr_fc(self, flag):
    """
    Parameters:
     - flag
    """
    pass

  def get_ftp_tp_info(self, ftpUrl, ftpPort, username, pwd, filePath, directory, operation, localActive):
    """
    Parameters:
     - ftpUrl
     - ftpPort
     - username
     - pwd
     - filePath
     - directory
     - operation
     - localActive
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def wakeUpDevice(self, ):
    self.send_wakeUpDevice()
    self.recv_wakeUpDevice()

  def send_wakeUpDevice(self, ):
    self._oprot.writeMessageBegin('wakeUpDevice', TMessageType.CALL, self._seqid)
    args = wakeUpDevice_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_wakeUpDevice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = wakeUpDevice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def unregisterAlarmer(self, ):
    self.send_unregisterAlarmer()
    self.recv_unregisterAlarmer()

  def send_unregisterAlarmer(self, ):
    self._oprot.writeMessageBegin('unregisterAlarmer', TMessageType.CALL, self._seqid)
    args = unregisterAlarmer_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unregisterAlarmer(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unregisterAlarmer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def send_mms(self, smsto, content):
    """
    Parameters:
     - smsto
     - content
    """
    self.send_send_mms(smsto, content)
    self.recv_send_mms()

  def send_send_mms(self, smsto, content):
    self._oprot.writeMessageBegin('send_mms', TMessageType.CALL, self._seqid)
    args = send_mms_args()
    args.smsto = smsto
    args.content = content
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_send_mms(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = send_mms_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def mt_trigger_service(self, map_trigger):
    """
    Parameters:
     - map_trigger
    """
    self.send_mt_trigger_service(map_trigger)
    return self.recv_mt_trigger_service()

  def send_mt_trigger_service(self, map_trigger):
    self._oprot.writeMessageBegin('mt_trigger_service', TMessageType.CALL, self._seqid)
    args = mt_trigger_service_args()
    args.map_trigger = map_trigger
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mt_trigger_service(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mt_trigger_service_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mt_trigger_service failed: unknown result");

  def get_postion(self, ):
    self.send_get_postion()
    return self.recv_get_postion()

  def send_get_postion(self, ):
    self._oprot.writeMessageBegin('get_postion', TMessageType.CALL, self._seqid)
    args = get_postion_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_postion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_postion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_postion failed: unknown result");

  def get_speed(self, ):
    self.send_get_speed()
    return self.recv_get_speed()

  def send_get_speed(self, ):
    self._oprot.writeMessageBegin('get_speed', TMessageType.CALL, self._seqid)
    args = get_speed_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_speed(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_speed_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_speed failed: unknown result");

  def get_battery_temperate(self, unit):
    """
    Parameters:
     - unit
    """
    self.send_get_battery_temperate(unit)
    return self.recv_get_battery_temperate()

  def send_get_battery_temperate(self, unit):
    self._oprot.writeMessageBegin('get_battery_temperate', TMessageType.CALL, self._seqid)
    args = get_battery_temperate_args()
    args.unit = unit
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_battery_temperate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_battery_temperate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_battery_temperate failed: unknown result");

  def get_orientation(self, ):
    self.send_get_orientation()
    return self.recv_get_orientation()

  def send_get_orientation(self, ):
    self._oprot.writeMessageBegin('get_orientation', TMessageType.CALL, self._seqid)
    args = get_orientation_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_orientation(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_orientation_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_orientation failed: unknown result");

  def get_available_ram(self, ):
    self.send_get_available_ram()
    return self.recv_get_available_ram()

  def send_get_available_ram(self, ):
    self._oprot.writeMessageBegin('get_available_ram', TMessageType.CALL, self._seqid)
    args = get_available_ram_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_available_ram(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_available_ram_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_available_ram failed: unknown result");

  def get_available_rom(self, ):
    self.send_get_available_rom()
    return self.recv_get_available_rom()

  def send_get_available_rom(self, ):
    self._oprot.writeMessageBegin('get_available_rom', TMessageType.CALL, self._seqid)
    args = get_available_rom_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_available_rom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_available_rom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_available_rom failed: unknown result");

  def get_wifi_rssi(self, ):
    self.send_get_wifi_rssi()
    return self.recv_get_wifi_rssi()

  def send_get_wifi_rssi(self, ):
    self._oprot.writeMessageBegin('get_wifi_rssi', TMessageType.CALL, self._seqid)
    args = get_wifi_rssi_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_wifi_rssi(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_wifi_rssi_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_wifi_rssi failed: unknown result");

  def get_sim_card_state(self, slotId):
    """
    Parameters:
     - slotId
    """
    self.send_get_sim_card_state(slotId)
    return self.recv_get_sim_card_state()

  def send_get_sim_card_state(self, slotId):
    self._oprot.writeMessageBegin('get_sim_card_state', TMessageType.CALL, self._seqid)
    args = get_sim_card_state_args()
    args.slotId = slotId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_sim_card_state(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_sim_card_state_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sim_card_state failed: unknown result");

  def get_sim_card_rssi(self, slotId):
    """
    Parameters:
     - slotId
    """
    self.send_get_sim_card_rssi(slotId)
    return self.recv_get_sim_card_rssi()

  def send_get_sim_card_rssi(self, slotId):
    self._oprot.writeMessageBegin('get_sim_card_rssi', TMessageType.CALL, self._seqid)
    args = get_sim_card_rssi_args()
    args.slotId = slotId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_sim_card_rssi(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_sim_card_rssi_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sim_card_rssi failed: unknown result");

  def get_sim_card_vendor(self, slotId):
    """
    Parameters:
     - slotId
    """
    self.send_get_sim_card_vendor(slotId)
    return self.recv_get_sim_card_vendor()

  def send_get_sim_card_vendor(self, slotId):
    self._oprot.writeMessageBegin('get_sim_card_vendor', TMessageType.CALL, self._seqid)
    args = get_sim_card_vendor_args()
    args.slotId = slotId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_sim_card_vendor(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_sim_card_vendor_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_sim_card_vendor failed: unknown result");

  def is_bluetooth_enabled(self, ):
    self.send_is_bluetooth_enabled()
    return self.recv_is_bluetooth_enabled()

  def send_is_bluetooth_enabled(self, ):
    self._oprot.writeMessageBegin('is_bluetooth_enabled', TMessageType.CALL, self._seqid)
    args = is_bluetooth_enabled_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_bluetooth_enabled(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_bluetooth_enabled_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_bluetooth_enabled failed: unknown result");

  def is_wifi_enabled(self, ):
    self.send_is_wifi_enabled()
    return self.recv_is_wifi_enabled()

  def send_is_wifi_enabled(self, ):
    self._oprot.writeMessageBegin('is_wifi_enabled', TMessageType.CALL, self._seqid)
    args = is_wifi_enabled_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_wifi_enabled(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_wifi_enabled_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_wifi_enabled failed: unknown result");

  def get_networktype(self, slotId):
    """
    Parameters:
     - slotId
    """
    self.send_get_networktype(slotId)
    return self.recv_get_networktype()

  def send_get_networktype(self, slotId):
    self._oprot.writeMessageBegin('get_networktype', TMessageType.CALL, self._seqid)
    args = get_networktype_args()
    args.slotId = slotId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_networktype(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_networktype_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_networktype failed: unknown result");

  def update_notificationbar(self, text):
    """
    Parameters:
     - text
    """
    self.send_update_notificationbar(text)
    self.recv_update_notificationbar()

  def send_update_notificationbar(self, text):
    self._oprot.writeMessageBegin('update_notificationbar', TMessageType.CALL, self._seqid)
    args = update_notificationbar_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_notificationbar(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_notificationbar_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def interactWithUserBySingleBtn(self, title, msg, send_to, send_msg, enable_ring_shake, wait_timeout):
    """
    Parameters:
     - title
     - msg
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
    """
    self.send_interactWithUserBySingleBtn(title, msg, send_to, send_msg, enable_ring_shake, wait_timeout)
    self.recv_interactWithUserBySingleBtn()

  def send_interactWithUserBySingleBtn(self, title, msg, send_to, send_msg, enable_ring_shake, wait_timeout):
    self._oprot.writeMessageBegin('interactWithUserBySingleBtn', TMessageType.CALL, self._seqid)
    args = interactWithUserBySingleBtn_args()
    args.title = title
    args.msg = msg
    args.send_to = send_to
    args.send_msg = send_msg
    args.enable_ring_shake = enable_ring_shake
    args.wait_timeout = wait_timeout
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_interactWithUserBySingleBtn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = interactWithUserBySingleBtn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def interactWithUserByMultiBtn(self, title, msg, btns, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    """
    Parameters:
     - title
     - msg
     - btns
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
     - default_result
    """
    self.send_interactWithUserByMultiBtn(title, msg, btns, send_to, send_msg, enable_ring_shake, wait_timeout, default_result)
    return self.recv_interactWithUserByMultiBtn()

  def send_interactWithUserByMultiBtn(self, title, msg, btns, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    self._oprot.writeMessageBegin('interactWithUserByMultiBtn', TMessageType.CALL, self._seqid)
    args = interactWithUserByMultiBtn_args()
    args.title = title
    args.msg = msg
    args.btns = btns
    args.send_to = send_to
    args.send_msg = send_msg
    args.enable_ring_shake = enable_ring_shake
    args.wait_timeout = wait_timeout
    args.default_result = default_result
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_interactWithUserByMultiBtn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = interactWithUserByMultiBtn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "interactWithUserByMultiBtn failed: unknown result");

  def interactWithUserByList(self, title, msg, value, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    """
    Parameters:
     - title
     - msg
     - value
     - send_to
     - send_msg
     - enable_ring_shake
     - wait_timeout
     - default_result
    """
    self.send_interactWithUserByList(title, msg, value, send_to, send_msg, enable_ring_shake, wait_timeout, default_result)
    return self.recv_interactWithUserByList()

  def send_interactWithUserByList(self, title, msg, value, send_to, send_msg, enable_ring_shake, wait_timeout, default_result):
    self._oprot.writeMessageBegin('interactWithUserByList', TMessageType.CALL, self._seqid)
    args = interactWithUserByList_args()
    args.title = title
    args.msg = msg
    args.value = value
    args.send_to = send_to
    args.send_msg = send_msg
    args.enable_ring_shake = enable_ring_shake
    args.wait_timeout = wait_timeout
    args.default_result = default_result
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_interactWithUserByList(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = interactWithUserByList_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "interactWithUserByList failed: unknown result");

  def goToSleepMode(self, interval):
    """
    Parameters:
     - interval
    """
    self.send_goToSleepMode(interval)
    return self.recv_goToSleepMode()

  def send_goToSleepMode(self, interval):
    self._oprot.writeMessageBegin('goToSleepMode', TMessageType.CALL, self._seqid)
    args = goToSleepMode_args()
    args.interval = interval
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_goToSleepMode(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = goToSleepMode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "goToSleepMode failed: unknown result");

  def get_value_from_client(self, name, value):
    """
    Parameters:
     - name
     - value
    """
    self.send_get_value_from_client(name, value)
    self.recv_get_value_from_client()

  def send_get_value_from_client(self, name, value):
    self._oprot.writeMessageBegin('get_value_from_client', TMessageType.CALL, self._seqid)
    args = get_value_from_client_args()
    args.name = name
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_value_from_client(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_value_from_client_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def getBluetoothName(self, ):
    self.send_getBluetoothName()
    return self.recv_getBluetoothName()

  def send_getBluetoothName(self, ):
    self._oprot.writeMessageBegin('getBluetoothName', TMessageType.CALL, self._seqid)
    args = getBluetoothName_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getBluetoothName(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getBluetoothName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getBluetoothName failed: unknown result");

  def getSerialNum(self, ):
    self.send_getSerialNum()
    return self.recv_getSerialNum()

  def send_getSerialNum(self, ):
    self._oprot.writeMessageBegin('getSerialNum', TMessageType.CALL, self._seqid)
    args = getSerialNum_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSerialNum(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSerialNum_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSerialNum failed: unknown result");

  def disable_watcher_anr_fc(self, flag):
    """
    Parameters:
     - flag
    """
    self.send_disable_watcher_anr_fc(flag)
    self.recv_disable_watcher_anr_fc()

  def send_disable_watcher_anr_fc(self, flag):
    self._oprot.writeMessageBegin('disable_watcher_anr_fc', TMessageType.CALL, self._seqid)
    args = disable_watcher_anr_fc_args()
    args.flag = flag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_disable_watcher_anr_fc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = disable_watcher_anr_fc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def get_ftp_tp_info(self, ftpUrl, ftpPort, username, pwd, filePath, directory, operation, localActive):
    """
    Parameters:
     - ftpUrl
     - ftpPort
     - username
     - pwd
     - filePath
     - directory
     - operation
     - localActive
    """
    self.send_get_ftp_tp_info(ftpUrl, ftpPort, username, pwd, filePath, directory, operation, localActive)
    return self.recv_get_ftp_tp_info()

  def send_get_ftp_tp_info(self, ftpUrl, ftpPort, username, pwd, filePath, directory, operation, localActive):
    self._oprot.writeMessageBegin('get_ftp_tp_info', TMessageType.CALL, self._seqid)
    args = get_ftp_tp_info_args()
    args.ftpUrl = ftpUrl
    args.ftpPort = ftpPort
    args.username = username
    args.pwd = pwd
    args.filePath = filePath
    args.directory = directory
    args.operation = operation
    args.localActive = localActive
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_ftp_tp_info(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_ftp_tp_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_ftp_tp_info failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["wakeUpDevice"] = Processor.process_wakeUpDevice
    self._processMap["unregisterAlarmer"] = Processor.process_unregisterAlarmer
    self._processMap["send_mms"] = Processor.process_send_mms
    self._processMap["mt_trigger_service"] = Processor.process_mt_trigger_service
    self._processMap["get_postion"] = Processor.process_get_postion
    self._processMap["get_speed"] = Processor.process_get_speed
    self._processMap["get_battery_temperate"] = Processor.process_get_battery_temperate
    self._processMap["get_orientation"] = Processor.process_get_orientation
    self._processMap["get_available_ram"] = Processor.process_get_available_ram
    self._processMap["get_available_rom"] = Processor.process_get_available_rom
    self._processMap["get_wifi_rssi"] = Processor.process_get_wifi_rssi
    self._processMap["get_sim_card_state"] = Processor.process_get_sim_card_state
    self._processMap["get_sim_card_rssi"] = Processor.process_get_sim_card_rssi
    self._processMap["get_sim_card_vendor"] = Processor.process_get_sim_card_vendor
    self._processMap["is_bluetooth_enabled"] = Processor.process_is_bluetooth_enabled
    self._processMap["is_wifi_enabled"] = Processor.process_is_wifi_enabled
    self._processMap["get_networktype"] = Processor.process_get_networktype
    self._processMap["update_notificationbar"] = Processor.process_update_notificationbar
    self._processMap["interactWithUserBySingleBtn"] = Processor.process_interactWithUserBySingleBtn
    self._processMap["interactWithUserByMultiBtn"] = Processor.process_interactWithUserByMultiBtn
    self._processMap["interactWithUserByList"] = Processor.process_interactWithUserByList
    self._processMap["goToSleepMode"] = Processor.process_goToSleepMode
    self._processMap["get_value_from_client"] = Processor.process_get_value_from_client
    self._processMap["getBluetoothName"] = Processor.process_getBluetoothName
    self._processMap["getSerialNum"] = Processor.process_getSerialNum
    self._processMap["disable_watcher_anr_fc"] = Processor.process_disable_watcher_anr_fc
    self._processMap["get_ftp_tp_info"] = Processor.process_get_ftp_tp_info

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_wakeUpDevice(self, seqid, iprot, oprot):
    args = wakeUpDevice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = wakeUpDevice_result()
    try:
      self._handler.wakeUpDevice()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("wakeUpDevice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unregisterAlarmer(self, seqid, iprot, oprot):
    args = unregisterAlarmer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unregisterAlarmer_result()
    try:
      self._handler.unregisterAlarmer()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("unregisterAlarmer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_send_mms(self, seqid, iprot, oprot):
    args = send_mms_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = send_mms_result()
    try:
      self._handler.send_mms(args.smsto, args.content)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("send_mms", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mt_trigger_service(self, seqid, iprot, oprot):
    args = mt_trigger_service_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mt_trigger_service_result()
    try:
      result.success = self._handler.mt_trigger_service(args.map_trigger)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("mt_trigger_service", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_postion(self, seqid, iprot, oprot):
    args = get_postion_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_postion_result()
    try:
      result.success = self._handler.get_postion()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_postion", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_speed(self, seqid, iprot, oprot):
    args = get_speed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_speed_result()
    try:
      result.success = self._handler.get_speed()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_speed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_battery_temperate(self, seqid, iprot, oprot):
    args = get_battery_temperate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_battery_temperate_result()
    try:
      result.success = self._handler.get_battery_temperate(args.unit)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_battery_temperate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_orientation(self, seqid, iprot, oprot):
    args = get_orientation_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_orientation_result()
    try:
      result.success = self._handler.get_orientation()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_orientation", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_available_ram(self, seqid, iprot, oprot):
    args = get_available_ram_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_available_ram_result()
    try:
      result.success = self._handler.get_available_ram()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_available_ram", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_available_rom(self, seqid, iprot, oprot):
    args = get_available_rom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_available_rom_result()
    try:
      result.success = self._handler.get_available_rom()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_available_rom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_wifi_rssi(self, seqid, iprot, oprot):
    args = get_wifi_rssi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_wifi_rssi_result()
    try:
      result.success = self._handler.get_wifi_rssi()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_wifi_rssi", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_sim_card_state(self, seqid, iprot, oprot):
    args = get_sim_card_state_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_sim_card_state_result()
    try:
      result.success = self._handler.get_sim_card_state(args.slotId)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_sim_card_state", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_sim_card_rssi(self, seqid, iprot, oprot):
    args = get_sim_card_rssi_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_sim_card_rssi_result()
    try:
      result.success = self._handler.get_sim_card_rssi(args.slotId)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_sim_card_rssi", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_sim_card_vendor(self, seqid, iprot, oprot):
    args = get_sim_card_vendor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_sim_card_vendor_result()
    try:
      result.success = self._handler.get_sim_card_vendor(args.slotId)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_sim_card_vendor", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_bluetooth_enabled(self, seqid, iprot, oprot):
    args = is_bluetooth_enabled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_bluetooth_enabled_result()
    try:
      result.success = self._handler.is_bluetooth_enabled()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_bluetooth_enabled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_wifi_enabled(self, seqid, iprot, oprot):
    args = is_wifi_enabled_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_wifi_enabled_result()
    try:
      result.success = self._handler.is_wifi_enabled()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_wifi_enabled", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_networktype(self, seqid, iprot, oprot):
    args = get_networktype_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_networktype_result()
    try:
      result.success = self._handler.get_networktype(args.slotId)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_networktype", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_notificationbar(self, seqid, iprot, oprot):
    args = update_notificationbar_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_notificationbar_result()
    try:
      self._handler.update_notificationbar(args.text)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("update_notificationbar", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_interactWithUserBySingleBtn(self, seqid, iprot, oprot):
    args = interactWithUserBySingleBtn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = interactWithUserBySingleBtn_result()
    try:
      self._handler.interactWithUserBySingleBtn(args.title, args.msg, args.send_to, args.send_msg, args.enable_ring_shake, args.wait_timeout)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("interactWithUserBySingleBtn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_interactWithUserByMultiBtn(self, seqid, iprot, oprot):
    args = interactWithUserByMultiBtn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = interactWithUserByMultiBtn_result()
    try:
      result.success = self._handler.interactWithUserByMultiBtn(args.title, args.msg, args.btns, args.send_to, args.send_msg, args.enable_ring_shake, args.wait_timeout, args.default_result)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("interactWithUserByMultiBtn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_interactWithUserByList(self, seqid, iprot, oprot):
    args = interactWithUserByList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = interactWithUserByList_result()
    try:
      result.success = self._handler.interactWithUserByList(args.title, args.msg, args.value, args.send_to, args.send_msg, args.enable_ring_shake, args.wait_timeout, args.default_result)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("interactWithUserByList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_goToSleepMode(self, seqid, iprot, oprot):
    args = goToSleepMode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = goToSleepMode_result()
    try:
      result.success = self._handler.goToSleepMode(args.interval)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("goToSleepMode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_value_from_client(self, seqid, iprot, oprot):
    args = get_value_from_client_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_value_from_client_result()
    try:
      self._handler.get_value_from_client(args.name, args.value)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_value_from_client", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getBluetoothName(self, seqid, iprot, oprot):
    args = getBluetoothName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getBluetoothName_result()
    try:
      result.success = self._handler.getBluetoothName()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("getBluetoothName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSerialNum(self, seqid, iprot, oprot):
    args = getSerialNum_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSerialNum_result()
    try:
      result.success = self._handler.getSerialNum()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("getSerialNum", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_disable_watcher_anr_fc(self, seqid, iprot, oprot):
    args = disable_watcher_anr_fc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = disable_watcher_anr_fc_result()
    try:
      self._handler.disable_watcher_anr_fc(args.flag)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("disable_watcher_anr_fc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_ftp_tp_info(self, seqid, iprot, oprot):
    args = get_ftp_tp_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_ftp_tp_info_result()
    try:
      result.success = self._handler.get_ftp_tp_info(args.ftpUrl, args.ftpPort, args.username, args.pwd, args.filePath, args.directory, args.operation, args.localActive)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_ftp_tp_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class wakeUpDevice_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wakeUpDevice_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class wakeUpDevice_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('wakeUpDevice_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregisterAlarmer_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregisterAlarmer_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregisterAlarmer_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregisterAlarmer_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_mms_args:
  """
  Attributes:
   - smsto
   - content
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'smsto', None, None, ), # 1
    (2, TType.STRING, 'content', None, None, ), # 2
  )

  def __init__(self, smsto=None, content=None,):
    self.smsto = smsto
    self.content = content

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.smsto = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.content = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_mms_args')
    if self.smsto is not None:
      oprot.writeFieldBegin('smsto', TType.STRING, 1)
      oprot.writeString(self.smsto)
      oprot.writeFieldEnd()
    if self.content is not None:
      oprot.writeFieldBegin('content', TType.STRING, 2)
      oprot.writeString(self.content)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_mms_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_mms_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mt_trigger_service_args:
  """
  Attributes:
   - map_trigger
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'map_trigger', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, map_trigger=None,):
    self.map_trigger = map_trigger

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.map_trigger = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.map_trigger[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mt_trigger_service_args')
    if self.map_trigger is not None:
      oprot.writeFieldBegin('map_trigger', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.map_trigger))
      for kiter7,viter8 in self.map_trigger.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mt_trigger_service_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mt_trigger_service_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_postion_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_postion_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_postion_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_postion_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_speed_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_speed_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_speed_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_speed_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_battery_temperate_args:
  """
  Attributes:
   - unit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'unit', None, None, ), # 1
  )

  def __init__(self, unit=None,):
    self.unit = unit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.unit = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_battery_temperate_args')
    if self.unit is not None:
      oprot.writeFieldBegin('unit', TType.STRING, 1)
      oprot.writeString(self.unit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_battery_temperate_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_battery_temperate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_orientation_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_orientation_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_orientation_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_orientation_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_available_ram_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_available_ram_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_available_ram_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_available_ram_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_available_rom_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_available_rom_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_available_rom_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_available_rom_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_wifi_rssi_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_wifi_rssi_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_wifi_rssi_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_wifi_rssi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_state_args:
  """
  Attributes:
   - slotId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'slotId', None, None, ), # 1
  )

  def __init__(self, slotId=None,):
    self.slotId = slotId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.slotId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_state_args')
    if self.slotId is not None:
      oprot.writeFieldBegin('slotId', TType.I32, 1)
      oprot.writeI32(self.slotId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_state_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_state_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_rssi_args:
  """
  Attributes:
   - slotId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'slotId', None, None, ), # 1
  )

  def __init__(self, slotId=None,):
    self.slotId = slotId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.slotId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_rssi_args')
    if self.slotId is not None:
      oprot.writeFieldBegin('slotId', TType.I32, 1)
      oprot.writeI32(self.slotId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_rssi_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_rssi_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_vendor_args:
  """
  Attributes:
   - slotId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'slotId', None, None, ), # 1
  )

  def __init__(self, slotId=None,):
    self.slotId = slotId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.slotId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_vendor_args')
    if self.slotId is not None:
      oprot.writeFieldBegin('slotId', TType.STRING, 1)
      oprot.writeString(self.slotId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_sim_card_vendor_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_sim_card_vendor_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_bluetooth_enabled_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_bluetooth_enabled_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_bluetooth_enabled_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_bluetooth_enabled_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_wifi_enabled_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_wifi_enabled_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_wifi_enabled_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_wifi_enabled_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_networktype_args:
  """
  Attributes:
   - slotId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'slotId', None, None, ), # 1
  )

  def __init__(self, slotId=None,):
    self.slotId = slotId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.slotId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_networktype_args')
    if self.slotId is not None:
      oprot.writeFieldBegin('slotId', TType.I32, 1)
      oprot.writeI32(self.slotId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_networktype_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_networktype_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_notificationbar_args:
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_notificationbar_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_notificationbar_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_notificationbar_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserBySingleBtn_args:
  """
  Attributes:
   - title
   - msg
   - send_to
   - send_msg
   - enable_ring_shake
   - wait_timeout
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'title', None, None, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
    (3, TType.STRING, 'send_to', None, None, ), # 3
    (4, TType.STRING, 'send_msg', None, None, ), # 4
    (5, TType.BOOL, 'enable_ring_shake', None, None, ), # 5
    (6, TType.I32, 'wait_timeout', None, None, ), # 6
  )

  def __init__(self, title=None, msg=None, send_to=None, send_msg=None, enable_ring_shake=None, wait_timeout=None,):
    self.title = title
    self.msg = msg
    self.send_to = send_to
    self.send_msg = send_msg
    self.enable_ring_shake = enable_ring_shake
    self.wait_timeout = wait_timeout

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.send_to = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.send_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.enable_ring_shake = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.wait_timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserBySingleBtn_args')
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 1)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    if self.send_to is not None:
      oprot.writeFieldBegin('send_to', TType.STRING, 3)
      oprot.writeString(self.send_to)
      oprot.writeFieldEnd()
    if self.send_msg is not None:
      oprot.writeFieldBegin('send_msg', TType.STRING, 4)
      oprot.writeString(self.send_msg)
      oprot.writeFieldEnd()
    if self.enable_ring_shake is not None:
      oprot.writeFieldBegin('enable_ring_shake', TType.BOOL, 5)
      oprot.writeBool(self.enable_ring_shake)
      oprot.writeFieldEnd()
    if self.wait_timeout is not None:
      oprot.writeFieldBegin('wait_timeout', TType.I32, 6)
      oprot.writeI32(self.wait_timeout)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserBySingleBtn_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserBySingleBtn_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserByMultiBtn_args:
  """
  Attributes:
   - title
   - msg
   - btns
   - send_to
   - send_msg
   - enable_ring_shake
   - wait_timeout
   - default_result
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'title', None, None, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
    (3, TType.LIST, 'btns', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'send_to', None, None, ), # 4
    (5, TType.STRING, 'send_msg', None, None, ), # 5
    (6, TType.BOOL, 'enable_ring_shake', None, None, ), # 6
    (7, TType.I32, 'wait_timeout', None, None, ), # 7
    (8, TType.I32, 'default_result', None, None, ), # 8
  )

  def __init__(self, title=None, msg=None, btns=None, send_to=None, send_msg=None, enable_ring_shake=None, wait_timeout=None, default_result=None,):
    self.title = title
    self.msg = msg
    self.btns = btns
    self.send_to = send_to
    self.send_msg = send_msg
    self.enable_ring_shake = enable_ring_shake
    self.wait_timeout = wait_timeout
    self.default_result = default_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.btns = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString();
            self.btns.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.send_to = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.send_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_ring_shake = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.wait_timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.default_result = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserByMultiBtn_args')
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 1)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    if self.btns is not None:
      oprot.writeFieldBegin('btns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.btns))
      for iter15 in self.btns:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.send_to is not None:
      oprot.writeFieldBegin('send_to', TType.STRING, 4)
      oprot.writeString(self.send_to)
      oprot.writeFieldEnd()
    if self.send_msg is not None:
      oprot.writeFieldBegin('send_msg', TType.STRING, 5)
      oprot.writeString(self.send_msg)
      oprot.writeFieldEnd()
    if self.enable_ring_shake is not None:
      oprot.writeFieldBegin('enable_ring_shake', TType.BOOL, 6)
      oprot.writeBool(self.enable_ring_shake)
      oprot.writeFieldEnd()
    if self.wait_timeout is not None:
      oprot.writeFieldBegin('wait_timeout', TType.I32, 7)
      oprot.writeI32(self.wait_timeout)
      oprot.writeFieldEnd()
    if self.default_result is not None:
      oprot.writeFieldBegin('default_result', TType.I32, 8)
      oprot.writeI32(self.default_result)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserByMultiBtn_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserByMultiBtn_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserByList_args:
  """
  Attributes:
   - title
   - msg
   - value
   - send_to
   - send_msg
   - enable_ring_shake
   - wait_timeout
   - default_result
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'title', None, None, ), # 1
    (2, TType.STRING, 'msg', None, None, ), # 2
    (3, TType.LIST, 'value', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'send_to', None, None, ), # 4
    (5, TType.STRING, 'send_msg', None, None, ), # 5
    (6, TType.BOOL, 'enable_ring_shake', None, None, ), # 6
    (7, TType.I32, 'wait_timeout', None, None, ), # 7
    (8, TType.I32, 'default_result', None, None, ), # 8
  )

  def __init__(self, title=None, msg=None, value=None, send_to=None, send_msg=None, enable_ring_shake=None, wait_timeout=None, default_result=None,):
    self.title = title
    self.msg = msg
    self.value = value
    self.send_to = send_to
    self.send_msg = send_msg
    self.enable_ring_shake = enable_ring_shake
    self.wait_timeout = wait_timeout
    self.default_result = default_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.value = []
          (_etype19, _size16) = iprot.readListBegin()
          for _i20 in xrange(_size16):
            _elem21 = iprot.readString();
            self.value.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.send_to = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.send_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.enable_ring_shake = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.wait_timeout = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.default_result = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserByList_args')
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 1)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 2)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.value))
      for iter22 in self.value:
        oprot.writeString(iter22)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.send_to is not None:
      oprot.writeFieldBegin('send_to', TType.STRING, 4)
      oprot.writeString(self.send_to)
      oprot.writeFieldEnd()
    if self.send_msg is not None:
      oprot.writeFieldBegin('send_msg', TType.STRING, 5)
      oprot.writeString(self.send_msg)
      oprot.writeFieldEnd()
    if self.enable_ring_shake is not None:
      oprot.writeFieldBegin('enable_ring_shake', TType.BOOL, 6)
      oprot.writeBool(self.enable_ring_shake)
      oprot.writeFieldEnd()
    if self.wait_timeout is not None:
      oprot.writeFieldBegin('wait_timeout', TType.I32, 7)
      oprot.writeI32(self.wait_timeout)
      oprot.writeFieldEnd()
    if self.default_result is not None:
      oprot.writeFieldBegin('default_result', TType.I32, 8)
      oprot.writeI32(self.default_result)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class interactWithUserByList_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('interactWithUserByList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goToSleepMode_args:
  """
  Attributes:
   - interval
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'interval', None, None, ), # 1
  )

  def __init__(self, interval=None,):
    self.interval = interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.interval = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goToSleepMode_args')
    if self.interval is not None:
      oprot.writeFieldBegin('interval', TType.I32, 1)
      oprot.writeI32(self.interval)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goToSleepMode_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goToSleepMode_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_value_from_client_args:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, name=None, value=None,):
    self.name = name
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_value_from_client_args')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_value_from_client_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_value_from_client_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBluetoothName_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBluetoothName_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getBluetoothName_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getBluetoothName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSerialNum_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSerialNum_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSerialNum_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSerialNum_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_watcher_anr_fc_args:
  """
  Attributes:
   - flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'flag', None, None, ), # 1
  )

  def __init__(self, flag=None,):
    self.flag = flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.flag = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_watcher_anr_fc_args')
    if self.flag is not None:
      oprot.writeFieldBegin('flag', TType.BOOL, 1)
      oprot.writeBool(self.flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_watcher_anr_fc_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_watcher_anr_fc_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_ftp_tp_info_args:
  """
  Attributes:
   - ftpUrl
   - ftpPort
   - username
   - pwd
   - filePath
   - directory
   - operation
   - localActive
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'ftpUrl', None, None, ), # 1
    (2, TType.I32, 'ftpPort', None, None, ), # 2
    (3, TType.STRING, 'username', None, None, ), # 3
    (4, TType.STRING, 'pwd', None, None, ), # 4
    (5, TType.STRING, 'filePath', None, None, ), # 5
    (6, TType.STRING, 'directory', None, None, ), # 6
    (7, TType.STRING, 'operation', None, None, ), # 7
    (8, TType.BOOL, 'localActive', None, None, ), # 8
  )

  def __init__(self, ftpUrl=None, ftpPort=None, username=None, pwd=None, filePath=None, directory=None, operation=None, localActive=None,):
    self.ftpUrl = ftpUrl
    self.ftpPort = ftpPort
    self.username = username
    self.pwd = pwd
    self.filePath = filePath
    self.directory = directory
    self.operation = operation
    self.localActive = localActive

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ftpUrl = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ftpPort = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.username = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.pwd = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.filePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.directory = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.operation = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.localActive = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_ftp_tp_info_args')
    if self.ftpUrl is not None:
      oprot.writeFieldBegin('ftpUrl', TType.STRING, 1)
      oprot.writeString(self.ftpUrl)
      oprot.writeFieldEnd()
    if self.ftpPort is not None:
      oprot.writeFieldBegin('ftpPort', TType.I32, 2)
      oprot.writeI32(self.ftpPort)
      oprot.writeFieldEnd()
    if self.username is not None:
      oprot.writeFieldBegin('username', TType.STRING, 3)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.pwd is not None:
      oprot.writeFieldBegin('pwd', TType.STRING, 4)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    if self.filePath is not None:
      oprot.writeFieldBegin('filePath', TType.STRING, 5)
      oprot.writeString(self.filePath)
      oprot.writeFieldEnd()
    if self.directory is not None:
      oprot.writeFieldBegin('directory', TType.STRING, 6)
      oprot.writeString(self.directory)
      oprot.writeFieldEnd()
    if self.operation is not None:
      oprot.writeFieldBegin('operation', TType.STRING, 7)
      oprot.writeString(self.operation)
      oprot.writeFieldEnd()
    if self.localActive is not None:
      oprot.writeFieldBegin('localActive', TType.BOOL, 8)
      oprot.writeBool(self.localActive)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_ftp_tp_info_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_ftp_tp_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
