#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def click_textview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_textview_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    pass

  def click_textview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - desc
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def get_textview_select_by_text(self, text):
    """
    Parameters:
     - text
    """
    pass

  def get_view_text_by_id(self, view_type, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - view_type
     - _id
     - isVerticalList
     - isScrollable
    """
    pass

  def get_view_text_by_index(self, view_type, index):
    """
    Parameters:
     - view_type
     - index
    """
    pass

  def click_textview_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def click_in_list_by_index(self, index, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - index
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_menuitem_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    pass

  def click_imageview_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def click_imageview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_imageview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - desc
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_button_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def click_button_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_button_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    pass

  def click_checkbox_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def click_checkbox_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    pass

  def click_view_by_container_id(self, _id, className, index):
    """
    Parameters:
     - _id
     - className
     - index
    """
    pass

  def click_view_by_container_desc(self, desc, className, index):
    """
    Parameters:
     - desc
     - className
     - index
    """
    pass

  def long_click(self, x, y):
    """
    Parameters:
     - x
     - y
    """
    pass

  def double_click(self, x, y):
    """
    Parameters:
     - x
     - y
    """
    pass

  def send_key(self, key, keyType):
    """
    Parameters:
     - key
     - keyType
    """
    pass

  def drag_by_param(self, startX, startY, endX, endY, stepCount):
    """
    Parameters:
     - startX
     - startY
     - endX
     - endY
     - stepCount
    """
    pass

  def scroll_up(self, ):
    pass

  def scroll_down(self, ):
    pass

  def scroll_to_bottom(self, ):
    pass

  def scroll_to_top(self, ):
    pass

  def entertext_edittext_by_id(self, _id, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - _id
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    pass

  def entertext_edittext_by_index(self, index, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - index
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    pass

  def entertext_edittext_on_focused(self, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    pass

  def clear_edittext_by_id(self, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
    """
    pass

  def clear_edittext_by_index(self, index, isVerticalList, isScrollable):
    """
    Parameters:
     - index
     - isVerticalList
     - isScrollable
    """
    pass

  def clear_edittext_on_focused(self, isVerticalList, isScrollable):
    """
    Parameters:
     - isVerticalList
     - isScrollable
    """
    pass

  def goback(self, className, idType, id):
    """
    Parameters:
     - className
     - idType
     - id
    """
    pass

  def shutdown(self, ):
    pass

  def search_text(self, text, isVerticalList, isScrollable, searchFlag):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
    """
    pass

  def get_text(self, text, isVerticaList, isScrollable, searchFlag):
    """
    Parameters:
     - text
     - isVerticaList
     - isScrollable
     - searchFlag
    """
    pass

  def search_webview_title(self, title):
    """
    Parameters:
     - title
    """
    pass

  def is_checkbox_checked_by_text(self, text):
    """
    Parameters:
     - text
    """
    pass

  def is_checkbox_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def is_togglebutton_checked_by_text(self, text):
    """
    Parameters:
     - text
    """
    pass

  def is_togglebutton_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def is_compoundbutton_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    pass

  def is_view_enabled_by_id(self, view_type, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - view_type
     - _id
     - isVerticalList
     - isScrollable
    """
    pass

  def is_view_enabled_by_text(self, view_type, text, isVerticalList, isScrollable, searchFlag):
    """
    Parameters:
     - view_type
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
    """
    pass

  def is_view_enabled_by_index(self, view_type, index):
    """
    Parameters:
     - view_type
     - index
    """
    pass

  def set_progressbar_by_index(self, index, value):
    """
    Parameters:
     - index
     - value
    """
    pass

  def search_view_by_id(self, _id):
    """
    Parameters:
     - _id
    """
    pass

  def search_view_by_desc(self, desc):
    """
    Parameters:
     - desc
    """
    pass

  def is_external_storage_enable(self, ):
    pass

  def get_system_language(self, ):
    pass

  def get_activity_name(self, ):
    pass

  def register_update_watcher(self, appName, className, idType, id, action):
    """
    Parameters:
     - appName
     - className
     - idType
     - id
     - action
    """
    pass

  def register_condition_action_watcher(self, packageName_condition, className_condition, idType_condition, id_condition, action, className_action, idType_action, id_action):
    """
    Parameters:
     - packageName_condition
     - className_condition
     - idType_condition
     - id_condition
     - action
     - className_action
     - idType_action
     - id_action
    """
    pass

  def unregister_update_watcher(self, appName):
    """
    Parameters:
     - appName
    """
    pass

  def zoom_by_param(self, mode, startX1, startY1, startX2, startY2):
    """
    Parameters:
     - mode
     - startX1
     - startY1
     - startX2
     - startY2
    """
    pass

  def getDisplayWidth(self, ):
    pass

  def getDisplayHeight(self, ):
    pass

  def goToSleepMode(self, interval):
    """
    Parameters:
     - interval
    """
    pass

  def enable_scroll_profling(self, ):
    pass

  def disable_scroll_profling(self, ):
    pass

  def excute(self, codes):
    """
    Parameters:
     - codes
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def click_textview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_textview_by_id(_id, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_textview_by_id()

  def send_click_textview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_textview_by_id', TMessageType.CALL, self._seqid)
    args = click_textview_by_id_args()
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_textview_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_textview_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_textview_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    self.send_click_textview_by_text(text, isVerticalList, isScrollable, searchFlag, waitForView, clickType)
    self.recv_click_textview_by_text()

  def send_click_textview_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    self._oprot.writeMessageBegin('click_textview_by_text', TMessageType.CALL, self._seqid)
    args = click_textview_by_text_args()
    args.text = text
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_textview_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_textview_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_textview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - desc
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_textview_by_desc(desc, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_textview_by_desc()

  def send_click_textview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_textview_by_desc', TMessageType.CALL, self._seqid)
    args = click_textview_by_desc_args()
    args.desc = desc
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_textview_by_desc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_textview_by_desc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def get_textview_select_by_text(self, text):
    """
    Parameters:
     - text
    """
    self.send_get_textview_select_by_text(text)
    return self.recv_get_textview_select_by_text()

  def send_get_textview_select_by_text(self, text):
    self._oprot.writeMessageBegin('get_textview_select_by_text', TMessageType.CALL, self._seqid)
    args = get_textview_select_by_text_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_textview_select_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_textview_select_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_textview_select_by_text failed: unknown result");

  def get_view_text_by_id(self, view_type, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - view_type
     - _id
     - isVerticalList
     - isScrollable
    """
    self.send_get_view_text_by_id(view_type, _id, isVerticalList, isScrollable)
    return self.recv_get_view_text_by_id()

  def send_get_view_text_by_id(self, view_type, _id, isVerticalList, isScrollable):
    self._oprot.writeMessageBegin('get_view_text_by_id', TMessageType.CALL, self._seqid)
    args = get_view_text_by_id_args()
    args.view_type = view_type
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_view_text_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_view_text_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_view_text_by_id failed: unknown result");

  def get_view_text_by_index(self, view_type, index):
    """
    Parameters:
     - view_type
     - index
    """
    self.send_get_view_text_by_index(view_type, index)
    return self.recv_get_view_text_by_index()

  def send_get_view_text_by_index(self, view_type, index):
    self._oprot.writeMessageBegin('get_view_text_by_index', TMessageType.CALL, self._seqid)
    args = get_view_text_by_index_args()
    args.view_type = view_type
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_view_text_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_view_text_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_view_text_by_index failed: unknown result");

  def click_textview_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_click_textview_by_index(index)
    self.recv_click_textview_by_index()

  def send_click_textview_by_index(self, index):
    self._oprot.writeMessageBegin('click_textview_by_index', TMessageType.CALL, self._seqid)
    args = click_textview_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_textview_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_textview_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_in_list_by_index(self, index, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - index
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_in_list_by_index(index, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_in_list_by_index()

  def send_click_in_list_by_index(self, index, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_in_list_by_index', TMessageType.CALL, self._seqid)
    args = click_in_list_by_index_args()
    args.index = index
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_in_list_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_in_list_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_menuitem_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    self.send_click_menuitem_by_text(text, isVerticalList, isScrollable, searchFlag, waitForView, clickType)
    self.recv_click_menuitem_by_text()

  def send_click_menuitem_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    self._oprot.writeMessageBegin('click_menuitem_by_text', TMessageType.CALL, self._seqid)
    args = click_menuitem_by_text_args()
    args.text = text
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_menuitem_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_menuitem_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_imageview_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_click_imageview_by_index(index)
    self.recv_click_imageview_by_index()

  def send_click_imageview_by_index(self, index):
    self._oprot.writeMessageBegin('click_imageview_by_index', TMessageType.CALL, self._seqid)
    args = click_imageview_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_imageview_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_imageview_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_imageview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_imageview_by_id(_id, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_imageview_by_id()

  def send_click_imageview_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_imageview_by_id', TMessageType.CALL, self._seqid)
    args = click_imageview_by_id_args()
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_imageview_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_imageview_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_imageview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - desc
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_imageview_by_desc(desc, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_imageview_by_desc()

  def send_click_imageview_by_desc(self, desc, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_imageview_by_desc', TMessageType.CALL, self._seqid)
    args = click_imageview_by_desc_args()
    args.desc = desc
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_imageview_by_desc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_imageview_by_desc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_button_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_click_button_by_index(index)
    self.recv_click_button_by_index()

  def send_click_button_by_index(self, index):
    self._oprot.writeMessageBegin('click_button_by_index', TMessageType.CALL, self._seqid)
    args = click_button_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_button_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_button_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_button_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_button_by_id(_id, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_button_by_id()

  def send_click_button_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_button_by_id', TMessageType.CALL, self._seqid)
    args = click_button_by_id_args()
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_button_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_button_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_button_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
     - waitForView
     - clickType
    """
    self.send_click_button_by_text(text, isVerticalList, isScrollable, searchFlag, waitForView, clickType)
    self.recv_click_button_by_text()

  def send_click_button_by_text(self, text, isVerticalList, isScrollable, searchFlag, waitForView, clickType):
    self._oprot.writeMessageBegin('click_button_by_text', TMessageType.CALL, self._seqid)
    args = click_button_by_text_args()
    args.text = text
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_button_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_button_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_checkbox_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_click_checkbox_by_index(index)
    self.recv_click_checkbox_by_index()

  def send_click_checkbox_by_index(self, index):
    self._oprot.writeMessageBegin('click_checkbox_by_index', TMessageType.CALL, self._seqid)
    args = click_checkbox_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_checkbox_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_checkbox_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_checkbox_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
     - waitForView
     - clickType
    """
    self.send_click_checkbox_by_id(_id, isVerticalList, isScrollable, waitForView, clickType)
    self.recv_click_checkbox_by_id()

  def send_click_checkbox_by_id(self, _id, isVerticalList, isScrollable, waitForView, clickType):
    self._oprot.writeMessageBegin('click_checkbox_by_id', TMessageType.CALL, self._seqid)
    args = click_checkbox_by_id_args()
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.waitForView = waitForView
    args.clickType = clickType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_checkbox_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_checkbox_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_view_by_container_id(self, _id, className, index):
    """
    Parameters:
     - _id
     - className
     - index
    """
    self.send_click_view_by_container_id(_id, className, index)
    self.recv_click_view_by_container_id()

  def send_click_view_by_container_id(self, _id, className, index):
    self._oprot.writeMessageBegin('click_view_by_container_id', TMessageType.CALL, self._seqid)
    args = click_view_by_container_id_args()
    args._id = _id
    args.className = className
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_view_by_container_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_view_by_container_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def click_view_by_container_desc(self, desc, className, index):
    """
    Parameters:
     - desc
     - className
     - index
    """
    self.send_click_view_by_container_desc(desc, className, index)
    self.recv_click_view_by_container_desc()

  def send_click_view_by_container_desc(self, desc, className, index):
    self._oprot.writeMessageBegin('click_view_by_container_desc', TMessageType.CALL, self._seqid)
    args = click_view_by_container_desc_args()
    args.desc = desc
    args.className = className
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_click_view_by_container_desc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = click_view_by_container_desc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def long_click(self, x, y):
    """
    Parameters:
     - x
     - y
    """
    self.send_long_click(x, y)
    self.recv_long_click()

  def send_long_click(self, x, y):
    self._oprot.writeMessageBegin('long_click', TMessageType.CALL, self._seqid)
    args = long_click_args()
    args.x = x
    args.y = y
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_long_click(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = long_click_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def double_click(self, x, y):
    """
    Parameters:
     - x
     - y
    """
    self.send_double_click(x, y)
    self.recv_double_click()

  def send_double_click(self, x, y):
    self._oprot.writeMessageBegin('double_click', TMessageType.CALL, self._seqid)
    args = double_click_args()
    args.x = x
    args.y = y
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_double_click(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = double_click_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def send_key(self, key, keyType):
    """
    Parameters:
     - key
     - keyType
    """
    self.send_send_key(key, keyType)
    self.recv_send_key()

  def send_send_key(self, key, keyType):
    self._oprot.writeMessageBegin('send_key', TMessageType.CALL, self._seqid)
    args = send_key_args()
    args.key = key
    args.keyType = keyType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_send_key(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = send_key_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def drag_by_param(self, startX, startY, endX, endY, stepCount):
    """
    Parameters:
     - startX
     - startY
     - endX
     - endY
     - stepCount
    """
    self.send_drag_by_param(startX, startY, endX, endY, stepCount)
    self.recv_drag_by_param()

  def send_drag_by_param(self, startX, startY, endX, endY, stepCount):
    self._oprot.writeMessageBegin('drag_by_param', TMessageType.CALL, self._seqid)
    args = drag_by_param_args()
    args.startX = startX
    args.startY = startY
    args.endX = endX
    args.endY = endY
    args.stepCount = stepCount
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_drag_by_param(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = drag_by_param_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def scroll_up(self, ):
    self.send_scroll_up()
    self.recv_scroll_up()

  def send_scroll_up(self, ):
    self._oprot.writeMessageBegin('scroll_up', TMessageType.CALL, self._seqid)
    args = scroll_up_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scroll_up(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scroll_up_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def scroll_down(self, ):
    self.send_scroll_down()
    self.recv_scroll_down()

  def send_scroll_down(self, ):
    self._oprot.writeMessageBegin('scroll_down', TMessageType.CALL, self._seqid)
    args = scroll_down_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scroll_down(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scroll_down_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def scroll_to_bottom(self, ):
    self.send_scroll_to_bottom()
    self.recv_scroll_to_bottom()

  def send_scroll_to_bottom(self, ):
    self._oprot.writeMessageBegin('scroll_to_bottom', TMessageType.CALL, self._seqid)
    args = scroll_to_bottom_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scroll_to_bottom(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scroll_to_bottom_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def scroll_to_top(self, ):
    self.send_scroll_to_top()
    self.recv_scroll_to_top()

  def send_scroll_to_top(self, ):
    self._oprot.writeMessageBegin('scroll_to_top', TMessageType.CALL, self._seqid)
    args = scroll_to_top_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_scroll_to_top(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = scroll_to_top_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def entertext_edittext_by_id(self, _id, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - _id
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    self.send_entertext_edittext_by_id(_id, value, isVerticalList, isScrollable, isClear)
    self.recv_entertext_edittext_by_id()

  def send_entertext_edittext_by_id(self, _id, value, isVerticalList, isScrollable, isClear):
    self._oprot.writeMessageBegin('entertext_edittext_by_id', TMessageType.CALL, self._seqid)
    args = entertext_edittext_by_id_args()
    args._id = _id
    args.value = value
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.isClear = isClear
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_entertext_edittext_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = entertext_edittext_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def entertext_edittext_by_index(self, index, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - index
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    self.send_entertext_edittext_by_index(index, value, isVerticalList, isScrollable, isClear)
    self.recv_entertext_edittext_by_index()

  def send_entertext_edittext_by_index(self, index, value, isVerticalList, isScrollable, isClear):
    self._oprot.writeMessageBegin('entertext_edittext_by_index', TMessageType.CALL, self._seqid)
    args = entertext_edittext_by_index_args()
    args.index = index
    args.value = value
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.isClear = isClear
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_entertext_edittext_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = entertext_edittext_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def entertext_edittext_on_focused(self, value, isVerticalList, isScrollable, isClear):
    """
    Parameters:
     - value
     - isVerticalList
     - isScrollable
     - isClear
    """
    self.send_entertext_edittext_on_focused(value, isVerticalList, isScrollable, isClear)
    self.recv_entertext_edittext_on_focused()

  def send_entertext_edittext_on_focused(self, value, isVerticalList, isScrollable, isClear):
    self._oprot.writeMessageBegin('entertext_edittext_on_focused', TMessageType.CALL, self._seqid)
    args = entertext_edittext_on_focused_args()
    args.value = value
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.isClear = isClear
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_entertext_edittext_on_focused(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = entertext_edittext_on_focused_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def clear_edittext_by_id(self, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - _id
     - isVerticalList
     - isScrollable
    """
    self.send_clear_edittext_by_id(_id, isVerticalList, isScrollable)
    self.recv_clear_edittext_by_id()

  def send_clear_edittext_by_id(self, _id, isVerticalList, isScrollable):
    self._oprot.writeMessageBegin('clear_edittext_by_id', TMessageType.CALL, self._seqid)
    args = clear_edittext_by_id_args()
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clear_edittext_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clear_edittext_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def clear_edittext_by_index(self, index, isVerticalList, isScrollable):
    """
    Parameters:
     - index
     - isVerticalList
     - isScrollable
    """
    self.send_clear_edittext_by_index(index, isVerticalList, isScrollable)
    self.recv_clear_edittext_by_index()

  def send_clear_edittext_by_index(self, index, isVerticalList, isScrollable):
    self._oprot.writeMessageBegin('clear_edittext_by_index', TMessageType.CALL, self._seqid)
    args = clear_edittext_by_index_args()
    args.index = index
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clear_edittext_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clear_edittext_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def clear_edittext_on_focused(self, isVerticalList, isScrollable):
    """
    Parameters:
     - isVerticalList
     - isScrollable
    """
    self.send_clear_edittext_on_focused(isVerticalList, isScrollable)
    self.recv_clear_edittext_on_focused()

  def send_clear_edittext_on_focused(self, isVerticalList, isScrollable):
    self._oprot.writeMessageBegin('clear_edittext_on_focused', TMessageType.CALL, self._seqid)
    args = clear_edittext_on_focused_args()
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clear_edittext_on_focused(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clear_edittext_on_focused_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def goback(self, className, idType, id):
    """
    Parameters:
     - className
     - idType
     - id
    """
    self.send_goback(className, idType, id)
    self.recv_goback()

  def send_goback(self, className, idType, id):
    self._oprot.writeMessageBegin('goback', TMessageType.CALL, self._seqid)
    args = goback_args()
    args.className = className
    args.idType = idType
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_goback(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = goback_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def shutdown(self, ):
    self.send_shutdown()
    self.recv_shutdown()

  def send_shutdown(self, ):
    self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
    args = shutdown_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_shutdown(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = shutdown_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def search_text(self, text, isVerticalList, isScrollable, searchFlag):
    """
    Parameters:
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
    """
    self.send_search_text(text, isVerticalList, isScrollable, searchFlag)
    return self.recv_search_text()

  def send_search_text(self, text, isVerticalList, isScrollable, searchFlag):
    self._oprot.writeMessageBegin('search_text', TMessageType.CALL, self._seqid)
    args = search_text_args()
    args.text = text
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = search_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search_text failed: unknown result");

  def get_text(self, text, isVerticaList, isScrollable, searchFlag):
    """
    Parameters:
     - text
     - isVerticaList
     - isScrollable
     - searchFlag
    """
    self.send_get_text(text, isVerticaList, isScrollable, searchFlag)
    return self.recv_get_text()

  def send_get_text(self, text, isVerticaList, isScrollable, searchFlag):
    self._oprot.writeMessageBegin('get_text', TMessageType.CALL, self._seqid)
    args = get_text_args()
    args.text = text
    args.isVerticaList = isVerticaList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_text failed: unknown result");

  def search_webview_title(self, title):
    """
    Parameters:
     - title
    """
    self.send_search_webview_title(title)
    return self.recv_search_webview_title()

  def send_search_webview_title(self, title):
    self._oprot.writeMessageBegin('search_webview_title', TMessageType.CALL, self._seqid)
    args = search_webview_title_args()
    args.title = title
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search_webview_title(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = search_webview_title_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search_webview_title failed: unknown result");

  def is_checkbox_checked_by_text(self, text):
    """
    Parameters:
     - text
    """
    self.send_is_checkbox_checked_by_text(text)
    return self.recv_is_checkbox_checked_by_text()

  def send_is_checkbox_checked_by_text(self, text):
    self._oprot.writeMessageBegin('is_checkbox_checked_by_text', TMessageType.CALL, self._seqid)
    args = is_checkbox_checked_by_text_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_checkbox_checked_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_checkbox_checked_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_checkbox_checked_by_text failed: unknown result");

  def is_checkbox_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_is_checkbox_checked_by_index(index)
    return self.recv_is_checkbox_checked_by_index()

  def send_is_checkbox_checked_by_index(self, index):
    self._oprot.writeMessageBegin('is_checkbox_checked_by_index', TMessageType.CALL, self._seqid)
    args = is_checkbox_checked_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_checkbox_checked_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_checkbox_checked_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_checkbox_checked_by_index failed: unknown result");

  def is_togglebutton_checked_by_text(self, text):
    """
    Parameters:
     - text
    """
    self.send_is_togglebutton_checked_by_text(text)
    return self.recv_is_togglebutton_checked_by_text()

  def send_is_togglebutton_checked_by_text(self, text):
    self._oprot.writeMessageBegin('is_togglebutton_checked_by_text', TMessageType.CALL, self._seqid)
    args = is_togglebutton_checked_by_text_args()
    args.text = text
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_togglebutton_checked_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_togglebutton_checked_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_togglebutton_checked_by_text failed: unknown result");

  def is_togglebutton_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_is_togglebutton_checked_by_index(index)
    return self.recv_is_togglebutton_checked_by_index()

  def send_is_togglebutton_checked_by_index(self, index):
    self._oprot.writeMessageBegin('is_togglebutton_checked_by_index', TMessageType.CALL, self._seqid)
    args = is_togglebutton_checked_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_togglebutton_checked_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_togglebutton_checked_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_togglebutton_checked_by_index failed: unknown result");

  def is_compoundbutton_checked_by_index(self, index):
    """
    Parameters:
     - index
    """
    self.send_is_compoundbutton_checked_by_index(index)
    return self.recv_is_compoundbutton_checked_by_index()

  def send_is_compoundbutton_checked_by_index(self, index):
    self._oprot.writeMessageBegin('is_compoundbutton_checked_by_index', TMessageType.CALL, self._seqid)
    args = is_compoundbutton_checked_by_index_args()
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_compoundbutton_checked_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_compoundbutton_checked_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_compoundbutton_checked_by_index failed: unknown result");

  def is_view_enabled_by_id(self, view_type, _id, isVerticalList, isScrollable):
    """
    Parameters:
     - view_type
     - _id
     - isVerticalList
     - isScrollable
    """
    self.send_is_view_enabled_by_id(view_type, _id, isVerticalList, isScrollable)
    return self.recv_is_view_enabled_by_id()

  def send_is_view_enabled_by_id(self, view_type, _id, isVerticalList, isScrollable):
    self._oprot.writeMessageBegin('is_view_enabled_by_id', TMessageType.CALL, self._seqid)
    args = is_view_enabled_by_id_args()
    args.view_type = view_type
    args._id = _id
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_view_enabled_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_view_enabled_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_view_enabled_by_id failed: unknown result");

  def is_view_enabled_by_text(self, view_type, text, isVerticalList, isScrollable, searchFlag):
    """
    Parameters:
     - view_type
     - text
     - isVerticalList
     - isScrollable
     - searchFlag
    """
    self.send_is_view_enabled_by_text(view_type, text, isVerticalList, isScrollable, searchFlag)
    return self.recv_is_view_enabled_by_text()

  def send_is_view_enabled_by_text(self, view_type, text, isVerticalList, isScrollable, searchFlag):
    self._oprot.writeMessageBegin('is_view_enabled_by_text', TMessageType.CALL, self._seqid)
    args = is_view_enabled_by_text_args()
    args.view_type = view_type
    args.text = text
    args.isVerticalList = isVerticalList
    args.isScrollable = isScrollable
    args.searchFlag = searchFlag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_view_enabled_by_text(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_view_enabled_by_text_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_view_enabled_by_text failed: unknown result");

  def is_view_enabled_by_index(self, view_type, index):
    """
    Parameters:
     - view_type
     - index
    """
    self.send_is_view_enabled_by_index(view_type, index)
    return self.recv_is_view_enabled_by_index()

  def send_is_view_enabled_by_index(self, view_type, index):
    self._oprot.writeMessageBegin('is_view_enabled_by_index', TMessageType.CALL, self._seqid)
    args = is_view_enabled_by_index_args()
    args.view_type = view_type
    args.index = index
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_view_enabled_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_view_enabled_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_view_enabled_by_index failed: unknown result");

  def set_progressbar_by_index(self, index, value):
    """
    Parameters:
     - index
     - value
    """
    self.send_set_progressbar_by_index(index, value)
    self.recv_set_progressbar_by_index()

  def send_set_progressbar_by_index(self, index, value):
    self._oprot.writeMessageBegin('set_progressbar_by_index', TMessageType.CALL, self._seqid)
    args = set_progressbar_by_index_args()
    args.index = index
    args.value = value
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_set_progressbar_by_index(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = set_progressbar_by_index_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def search_view_by_id(self, _id):
    """
    Parameters:
     - _id
    """
    self.send_search_view_by_id(_id)
    return self.recv_search_view_by_id()

  def send_search_view_by_id(self, _id):
    self._oprot.writeMessageBegin('search_view_by_id', TMessageType.CALL, self._seqid)
    args = search_view_by_id_args()
    args._id = _id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search_view_by_id(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = search_view_by_id_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search_view_by_id failed: unknown result");

  def search_view_by_desc(self, desc):
    """
    Parameters:
     - desc
    """
    self.send_search_view_by_desc(desc)
    return self.recv_search_view_by_desc()

  def send_search_view_by_desc(self, desc):
    self._oprot.writeMessageBegin('search_view_by_desc', TMessageType.CALL, self._seqid)
    args = search_view_by_desc_args()
    args.desc = desc
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_search_view_by_desc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = search_view_by_desc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "search_view_by_desc failed: unknown result");

  def is_external_storage_enable(self, ):
    self.send_is_external_storage_enable()
    return self.recv_is_external_storage_enable()

  def send_is_external_storage_enable(self, ):
    self._oprot.writeMessageBegin('is_external_storage_enable', TMessageType.CALL, self._seqid)
    args = is_external_storage_enable_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_is_external_storage_enable(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = is_external_storage_enable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "is_external_storage_enable failed: unknown result");

  def get_system_language(self, ):
    self.send_get_system_language()
    return self.recv_get_system_language()

  def send_get_system_language(self, ):
    self._oprot.writeMessageBegin('get_system_language', TMessageType.CALL, self._seqid)
    args = get_system_language_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_system_language(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_system_language_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_language failed: unknown result");

  def get_activity_name(self, ):
    self.send_get_activity_name()
    return self.recv_get_activity_name()

  def send_get_activity_name(self, ):
    self._oprot.writeMessageBegin('get_activity_name', TMessageType.CALL, self._seqid)
    args = get_activity_name_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_activity_name(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_activity_name_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_activity_name failed: unknown result");

  def register_update_watcher(self, appName, className, idType, id, action):
    """
    Parameters:
     - appName
     - className
     - idType
     - id
     - action
    """
    self.send_register_update_watcher(appName, className, idType, id, action)
    self.recv_register_update_watcher()

  def send_register_update_watcher(self, appName, className, idType, id, action):
    self._oprot.writeMessageBegin('register_update_watcher', TMessageType.CALL, self._seqid)
    args = register_update_watcher_args()
    args.appName = appName
    args.className = className
    args.idType = idType
    args.id = id
    args.action = action
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_update_watcher(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = register_update_watcher_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def register_condition_action_watcher(self, packageName_condition, className_condition, idType_condition, id_condition, action, className_action, idType_action, id_action):
    """
    Parameters:
     - packageName_condition
     - className_condition
     - idType_condition
     - id_condition
     - action
     - className_action
     - idType_action
     - id_action
    """
    self.send_register_condition_action_watcher(packageName_condition, className_condition, idType_condition, id_condition, action, className_action, idType_action, id_action)
    self.recv_register_condition_action_watcher()

  def send_register_condition_action_watcher(self, packageName_condition, className_condition, idType_condition, id_condition, action, className_action, idType_action, id_action):
    self._oprot.writeMessageBegin('register_condition_action_watcher', TMessageType.CALL, self._seqid)
    args = register_condition_action_watcher_args()
    args.packageName_condition = packageName_condition
    args.className_condition = className_condition
    args.idType_condition = idType_condition
    args.id_condition = id_condition
    args.action = action
    args.className_action = className_action
    args.idType_action = idType_action
    args.id_action = id_action
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_register_condition_action_watcher(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = register_condition_action_watcher_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def unregister_update_watcher(self, appName):
    """
    Parameters:
     - appName
    """
    self.send_unregister_update_watcher(appName)
    self.recv_unregister_update_watcher()

  def send_unregister_update_watcher(self, appName):
    self._oprot.writeMessageBegin('unregister_update_watcher', TMessageType.CALL, self._seqid)
    args = unregister_update_watcher_args()
    args.appName = appName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_unregister_update_watcher(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = unregister_update_watcher_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def zoom_by_param(self, mode, startX1, startY1, startX2, startY2):
    """
    Parameters:
     - mode
     - startX1
     - startY1
     - startX2
     - startY2
    """
    self.send_zoom_by_param(mode, startX1, startY1, startX2, startY2)
    self.recv_zoom_by_param()

  def send_zoom_by_param(self, mode, startX1, startY1, startX2, startY2):
    self._oprot.writeMessageBegin('zoom_by_param', TMessageType.CALL, self._seqid)
    args = zoom_by_param_args()
    args.mode = mode
    args.startX1 = startX1
    args.startY1 = startY1
    args.startX2 = startX2
    args.startY2 = startY2
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_zoom_by_param(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = zoom_by_param_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def getDisplayWidth(self, ):
    self.send_getDisplayWidth()
    return self.recv_getDisplayWidth()

  def send_getDisplayWidth(self, ):
    self._oprot.writeMessageBegin('getDisplayWidth', TMessageType.CALL, self._seqid)
    args = getDisplayWidth_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDisplayWidth(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDisplayWidth_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDisplayWidth failed: unknown result");

  def getDisplayHeight(self, ):
    self.send_getDisplayHeight()
    return self.recv_getDisplayHeight()

  def send_getDisplayHeight(self, ):
    self._oprot.writeMessageBegin('getDisplayHeight', TMessageType.CALL, self._seqid)
    args = getDisplayHeight_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDisplayHeight(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDisplayHeight_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.actionEx is not None:
      raise result.actionEx
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDisplayHeight failed: unknown result");

  def goToSleepMode(self, interval):
    """
    Parameters:
     - interval
    """
    self.send_goToSleepMode(interval)
    self.recv_goToSleepMode()

  def send_goToSleepMode(self, interval):
    self._oprot.writeMessageBegin('goToSleepMode', TMessageType.CALL, self._seqid)
    args = goToSleepMode_args()
    args.interval = interval
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_goToSleepMode(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = goToSleepMode_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def enable_scroll_profling(self, ):
    self.send_enable_scroll_profling()
    self.recv_enable_scroll_profling()

  def send_enable_scroll_profling(self, ):
    self._oprot.writeMessageBegin('enable_scroll_profling', TMessageType.CALL, self._seqid)
    args = enable_scroll_profling_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_enable_scroll_profling(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = enable_scroll_profling_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def disable_scroll_profling(self, ):
    self.send_disable_scroll_profling()
    self.recv_disable_scroll_profling()

  def send_disable_scroll_profling(self, ):
    self._oprot.writeMessageBegin('disable_scroll_profling', TMessageType.CALL, self._seqid)
    args = disable_scroll_profling_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_disable_scroll_profling(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = disable_scroll_profling_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return

  def excute(self, codes):
    """
    Parameters:
     - codes
    """
    self.send_excute(codes)
    self.recv_excute()

  def send_excute(self, codes):
    self._oprot.writeMessageBegin('excute', TMessageType.CALL, self._seqid)
    args = excute_args()
    args.codes = codes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_excute(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = excute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.actionEx is not None:
      raise result.actionEx
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["click_textview_by_id"] = Processor.process_click_textview_by_id
    self._processMap["click_textview_by_text"] = Processor.process_click_textview_by_text
    self._processMap["click_textview_by_desc"] = Processor.process_click_textview_by_desc
    self._processMap["get_textview_select_by_text"] = Processor.process_get_textview_select_by_text
    self._processMap["get_view_text_by_id"] = Processor.process_get_view_text_by_id
    self._processMap["get_view_text_by_index"] = Processor.process_get_view_text_by_index
    self._processMap["click_textview_by_index"] = Processor.process_click_textview_by_index
    self._processMap["click_in_list_by_index"] = Processor.process_click_in_list_by_index
    self._processMap["click_menuitem_by_text"] = Processor.process_click_menuitem_by_text
    self._processMap["click_imageview_by_index"] = Processor.process_click_imageview_by_index
    self._processMap["click_imageview_by_id"] = Processor.process_click_imageview_by_id
    self._processMap["click_imageview_by_desc"] = Processor.process_click_imageview_by_desc
    self._processMap["click_button_by_index"] = Processor.process_click_button_by_index
    self._processMap["click_button_by_id"] = Processor.process_click_button_by_id
    self._processMap["click_button_by_text"] = Processor.process_click_button_by_text
    self._processMap["click_checkbox_by_index"] = Processor.process_click_checkbox_by_index
    self._processMap["click_checkbox_by_id"] = Processor.process_click_checkbox_by_id
    self._processMap["click_view_by_container_id"] = Processor.process_click_view_by_container_id
    self._processMap["click_view_by_container_desc"] = Processor.process_click_view_by_container_desc
    self._processMap["long_click"] = Processor.process_long_click
    self._processMap["double_click"] = Processor.process_double_click
    self._processMap["send_key"] = Processor.process_send_key
    self._processMap["drag_by_param"] = Processor.process_drag_by_param
    self._processMap["scroll_up"] = Processor.process_scroll_up
    self._processMap["scroll_down"] = Processor.process_scroll_down
    self._processMap["scroll_to_bottom"] = Processor.process_scroll_to_bottom
    self._processMap["scroll_to_top"] = Processor.process_scroll_to_top
    self._processMap["entertext_edittext_by_id"] = Processor.process_entertext_edittext_by_id
    self._processMap["entertext_edittext_by_index"] = Processor.process_entertext_edittext_by_index
    self._processMap["entertext_edittext_on_focused"] = Processor.process_entertext_edittext_on_focused
    self._processMap["clear_edittext_by_id"] = Processor.process_clear_edittext_by_id
    self._processMap["clear_edittext_by_index"] = Processor.process_clear_edittext_by_index
    self._processMap["clear_edittext_on_focused"] = Processor.process_clear_edittext_on_focused
    self._processMap["goback"] = Processor.process_goback
    self._processMap["shutdown"] = Processor.process_shutdown
    self._processMap["search_text"] = Processor.process_search_text
    self._processMap["get_text"] = Processor.process_get_text
    self._processMap["search_webview_title"] = Processor.process_search_webview_title
    self._processMap["is_checkbox_checked_by_text"] = Processor.process_is_checkbox_checked_by_text
    self._processMap["is_checkbox_checked_by_index"] = Processor.process_is_checkbox_checked_by_index
    self._processMap["is_togglebutton_checked_by_text"] = Processor.process_is_togglebutton_checked_by_text
    self._processMap["is_togglebutton_checked_by_index"] = Processor.process_is_togglebutton_checked_by_index
    self._processMap["is_compoundbutton_checked_by_index"] = Processor.process_is_compoundbutton_checked_by_index
    self._processMap["is_view_enabled_by_id"] = Processor.process_is_view_enabled_by_id
    self._processMap["is_view_enabled_by_text"] = Processor.process_is_view_enabled_by_text
    self._processMap["is_view_enabled_by_index"] = Processor.process_is_view_enabled_by_index
    self._processMap["set_progressbar_by_index"] = Processor.process_set_progressbar_by_index
    self._processMap["search_view_by_id"] = Processor.process_search_view_by_id
    self._processMap["search_view_by_desc"] = Processor.process_search_view_by_desc
    self._processMap["is_external_storage_enable"] = Processor.process_is_external_storage_enable
    self._processMap["get_system_language"] = Processor.process_get_system_language
    self._processMap["get_activity_name"] = Processor.process_get_activity_name
    self._processMap["register_update_watcher"] = Processor.process_register_update_watcher
    self._processMap["register_condition_action_watcher"] = Processor.process_register_condition_action_watcher
    self._processMap["unregister_update_watcher"] = Processor.process_unregister_update_watcher
    self._processMap["zoom_by_param"] = Processor.process_zoom_by_param
    self._processMap["getDisplayWidth"] = Processor.process_getDisplayWidth
    self._processMap["getDisplayHeight"] = Processor.process_getDisplayHeight
    self._processMap["goToSleepMode"] = Processor.process_goToSleepMode
    self._processMap["enable_scroll_profling"] = Processor.process_enable_scroll_profling
    self._processMap["disable_scroll_profling"] = Processor.process_disable_scroll_profling
    self._processMap["excute"] = Processor.process_excute

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_click_textview_by_id(self, seqid, iprot, oprot):
    args = click_textview_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_textview_by_id_result()
    try:
      self._handler.click_textview_by_id(args._id, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_textview_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_textview_by_text(self, seqid, iprot, oprot):
    args = click_textview_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_textview_by_text_result()
    try:
      self._handler.click_textview_by_text(args.text, args.isVerticalList, args.isScrollable, args.searchFlag, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_textview_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_textview_by_desc(self, seqid, iprot, oprot):
    args = click_textview_by_desc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_textview_by_desc_result()
    try:
      self._handler.click_textview_by_desc(args.desc, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_textview_by_desc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_textview_select_by_text(self, seqid, iprot, oprot):
    args = get_textview_select_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_textview_select_by_text_result()
    try:
      result.success = self._handler.get_textview_select_by_text(args.text)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_textview_select_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_view_text_by_id(self, seqid, iprot, oprot):
    args = get_view_text_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_view_text_by_id_result()
    try:
      result.success = self._handler.get_view_text_by_id(args.view_type, args._id, args.isVerticalList, args.isScrollable)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_view_text_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_view_text_by_index(self, seqid, iprot, oprot):
    args = get_view_text_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_view_text_by_index_result()
    try:
      result.success = self._handler.get_view_text_by_index(args.view_type, args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_view_text_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_textview_by_index(self, seqid, iprot, oprot):
    args = click_textview_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_textview_by_index_result()
    try:
      self._handler.click_textview_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_textview_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_in_list_by_index(self, seqid, iprot, oprot):
    args = click_in_list_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_in_list_by_index_result()
    try:
      self._handler.click_in_list_by_index(args.index, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_in_list_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_menuitem_by_text(self, seqid, iprot, oprot):
    args = click_menuitem_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_menuitem_by_text_result()
    try:
      self._handler.click_menuitem_by_text(args.text, args.isVerticalList, args.isScrollable, args.searchFlag, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_menuitem_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_imageview_by_index(self, seqid, iprot, oprot):
    args = click_imageview_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_imageview_by_index_result()
    try:
      self._handler.click_imageview_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_imageview_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_imageview_by_id(self, seqid, iprot, oprot):
    args = click_imageview_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_imageview_by_id_result()
    try:
      self._handler.click_imageview_by_id(args._id, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_imageview_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_imageview_by_desc(self, seqid, iprot, oprot):
    args = click_imageview_by_desc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_imageview_by_desc_result()
    try:
      self._handler.click_imageview_by_desc(args.desc, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_imageview_by_desc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_button_by_index(self, seqid, iprot, oprot):
    args = click_button_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_button_by_index_result()
    try:
      self._handler.click_button_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_button_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_button_by_id(self, seqid, iprot, oprot):
    args = click_button_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_button_by_id_result()
    try:
      self._handler.click_button_by_id(args._id, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_button_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_button_by_text(self, seqid, iprot, oprot):
    args = click_button_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_button_by_text_result()
    try:
      self._handler.click_button_by_text(args.text, args.isVerticalList, args.isScrollable, args.searchFlag, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_button_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_checkbox_by_index(self, seqid, iprot, oprot):
    args = click_checkbox_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_checkbox_by_index_result()
    try:
      self._handler.click_checkbox_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_checkbox_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_checkbox_by_id(self, seqid, iprot, oprot):
    args = click_checkbox_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_checkbox_by_id_result()
    try:
      self._handler.click_checkbox_by_id(args._id, args.isVerticalList, args.isScrollable, args.waitForView, args.clickType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_checkbox_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_view_by_container_id(self, seqid, iprot, oprot):
    args = click_view_by_container_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_view_by_container_id_result()
    try:
      self._handler.click_view_by_container_id(args._id, args.className, args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_view_by_container_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_click_view_by_container_desc(self, seqid, iprot, oprot):
    args = click_view_by_container_desc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = click_view_by_container_desc_result()
    try:
      self._handler.click_view_by_container_desc(args.desc, args.className, args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("click_view_by_container_desc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_long_click(self, seqid, iprot, oprot):
    args = long_click_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = long_click_result()
    try:
      self._handler.long_click(args.x, args.y)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("long_click", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_double_click(self, seqid, iprot, oprot):
    args = double_click_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = double_click_result()
    try:
      self._handler.double_click(args.x, args.y)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("double_click", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_send_key(self, seqid, iprot, oprot):
    args = send_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = send_key_result()
    try:
      self._handler.send_key(args.key, args.keyType)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("send_key", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_drag_by_param(self, seqid, iprot, oprot):
    args = drag_by_param_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = drag_by_param_result()
    try:
      self._handler.drag_by_param(args.startX, args.startY, args.endX, args.endY, args.stepCount)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("drag_by_param", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scroll_up(self, seqid, iprot, oprot):
    args = scroll_up_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scroll_up_result()
    try:
      self._handler.scroll_up()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("scroll_up", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scroll_down(self, seqid, iprot, oprot):
    args = scroll_down_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scroll_down_result()
    try:
      self._handler.scroll_down()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("scroll_down", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scroll_to_bottom(self, seqid, iprot, oprot):
    args = scroll_to_bottom_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scroll_to_bottom_result()
    try:
      self._handler.scroll_to_bottom()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("scroll_to_bottom", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_scroll_to_top(self, seqid, iprot, oprot):
    args = scroll_to_top_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = scroll_to_top_result()
    try:
      self._handler.scroll_to_top()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("scroll_to_top", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_entertext_edittext_by_id(self, seqid, iprot, oprot):
    args = entertext_edittext_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = entertext_edittext_by_id_result()
    try:
      self._handler.entertext_edittext_by_id(args._id, args.value, args.isVerticalList, args.isScrollable, args.isClear)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("entertext_edittext_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_entertext_edittext_by_index(self, seqid, iprot, oprot):
    args = entertext_edittext_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = entertext_edittext_by_index_result()
    try:
      self._handler.entertext_edittext_by_index(args.index, args.value, args.isVerticalList, args.isScrollable, args.isClear)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("entertext_edittext_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_entertext_edittext_on_focused(self, seqid, iprot, oprot):
    args = entertext_edittext_on_focused_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = entertext_edittext_on_focused_result()
    try:
      self._handler.entertext_edittext_on_focused(args.value, args.isVerticalList, args.isScrollable, args.isClear)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("entertext_edittext_on_focused", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clear_edittext_by_id(self, seqid, iprot, oprot):
    args = clear_edittext_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clear_edittext_by_id_result()
    try:
      self._handler.clear_edittext_by_id(args._id, args.isVerticalList, args.isScrollable)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("clear_edittext_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clear_edittext_by_index(self, seqid, iprot, oprot):
    args = clear_edittext_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clear_edittext_by_index_result()
    try:
      self._handler.clear_edittext_by_index(args.index, args.isVerticalList, args.isScrollable)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("clear_edittext_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clear_edittext_on_focused(self, seqid, iprot, oprot):
    args = clear_edittext_on_focused_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clear_edittext_on_focused_result()
    try:
      self._handler.clear_edittext_on_focused(args.isVerticalList, args.isScrollable)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("clear_edittext_on_focused", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_goback(self, seqid, iprot, oprot):
    args = goback_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = goback_result()
    try:
      self._handler.goback(args.className, args.idType, args.id)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("goback", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_shutdown(self, seqid, iprot, oprot):
    args = shutdown_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = shutdown_result()
    try:
      self._handler.shutdown()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("shutdown", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search_text(self, seqid, iprot, oprot):
    args = search_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_text_result()
    try:
      result.success = self._handler.search_text(args.text, args.isVerticalList, args.isScrollable, args.searchFlag)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("search_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_text(self, seqid, iprot, oprot):
    args = get_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_text_result()
    try:
      result.success = self._handler.get_text(args.text, args.isVerticaList, args.isScrollable, args.searchFlag)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search_webview_title(self, seqid, iprot, oprot):
    args = search_webview_title_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_webview_title_result()
    try:
      result.success = self._handler.search_webview_title(args.title)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("search_webview_title", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_checkbox_checked_by_text(self, seqid, iprot, oprot):
    args = is_checkbox_checked_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_checkbox_checked_by_text_result()
    try:
      result.success = self._handler.is_checkbox_checked_by_text(args.text)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_checkbox_checked_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_checkbox_checked_by_index(self, seqid, iprot, oprot):
    args = is_checkbox_checked_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_checkbox_checked_by_index_result()
    try:
      result.success = self._handler.is_checkbox_checked_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_checkbox_checked_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_togglebutton_checked_by_text(self, seqid, iprot, oprot):
    args = is_togglebutton_checked_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_togglebutton_checked_by_text_result()
    try:
      result.success = self._handler.is_togglebutton_checked_by_text(args.text)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_togglebutton_checked_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_togglebutton_checked_by_index(self, seqid, iprot, oprot):
    args = is_togglebutton_checked_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_togglebutton_checked_by_index_result()
    try:
      result.success = self._handler.is_togglebutton_checked_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_togglebutton_checked_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_compoundbutton_checked_by_index(self, seqid, iprot, oprot):
    args = is_compoundbutton_checked_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_compoundbutton_checked_by_index_result()
    try:
      result.success = self._handler.is_compoundbutton_checked_by_index(args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_compoundbutton_checked_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_view_enabled_by_id(self, seqid, iprot, oprot):
    args = is_view_enabled_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_view_enabled_by_id_result()
    try:
      result.success = self._handler.is_view_enabled_by_id(args.view_type, args._id, args.isVerticalList, args.isScrollable)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_view_enabled_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_view_enabled_by_text(self, seqid, iprot, oprot):
    args = is_view_enabled_by_text_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_view_enabled_by_text_result()
    try:
      result.success = self._handler.is_view_enabled_by_text(args.view_type, args.text, args.isVerticalList, args.isScrollable, args.searchFlag)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_view_enabled_by_text", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_view_enabled_by_index(self, seqid, iprot, oprot):
    args = is_view_enabled_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_view_enabled_by_index_result()
    try:
      result.success = self._handler.is_view_enabled_by_index(args.view_type, args.index)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_view_enabled_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_set_progressbar_by_index(self, seqid, iprot, oprot):
    args = set_progressbar_by_index_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = set_progressbar_by_index_result()
    try:
      self._handler.set_progressbar_by_index(args.index, args.value)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("set_progressbar_by_index", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search_view_by_id(self, seqid, iprot, oprot):
    args = search_view_by_id_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_view_by_id_result()
    try:
      result.success = self._handler.search_view_by_id(args._id)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("search_view_by_id", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_search_view_by_desc(self, seqid, iprot, oprot):
    args = search_view_by_desc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = search_view_by_desc_result()
    try:
      result.success = self._handler.search_view_by_desc(args.desc)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("search_view_by_desc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_is_external_storage_enable(self, seqid, iprot, oprot):
    args = is_external_storage_enable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = is_external_storage_enable_result()
    try:
      result.success = self._handler.is_external_storage_enable()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("is_external_storage_enable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_system_language(self, seqid, iprot, oprot):
    args = get_system_language_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_system_language_result()
    try:
      result.success = self._handler.get_system_language()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_system_language", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_activity_name(self, seqid, iprot, oprot):
    args = get_activity_name_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_activity_name_result()
    try:
      result.success = self._handler.get_activity_name()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("get_activity_name", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_update_watcher(self, seqid, iprot, oprot):
    args = register_update_watcher_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_update_watcher_result()
    try:
      self._handler.register_update_watcher(args.appName, args.className, args.idType, args.id, args.action)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("register_update_watcher", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_register_condition_action_watcher(self, seqid, iprot, oprot):
    args = register_condition_action_watcher_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = register_condition_action_watcher_result()
    try:
      self._handler.register_condition_action_watcher(args.packageName_condition, args.className_condition, args.idType_condition, args.id_condition, args.action, args.className_action, args.idType_action, args.id_action)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("register_condition_action_watcher", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_unregister_update_watcher(self, seqid, iprot, oprot):
    args = unregister_update_watcher_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = unregister_update_watcher_result()
    try:
      self._handler.unregister_update_watcher(args.appName)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("unregister_update_watcher", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_zoom_by_param(self, seqid, iprot, oprot):
    args = zoom_by_param_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = zoom_by_param_result()
    try:
      self._handler.zoom_by_param(args.mode, args.startX1, args.startY1, args.startX2, args.startY2)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("zoom_by_param", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDisplayWidth(self, seqid, iprot, oprot):
    args = getDisplayWidth_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDisplayWidth_result()
    try:
      result.success = self._handler.getDisplayWidth()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("getDisplayWidth", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDisplayHeight(self, seqid, iprot, oprot):
    args = getDisplayHeight_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDisplayHeight_result()
    try:
      result.success = self._handler.getDisplayHeight()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("getDisplayHeight", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_goToSleepMode(self, seqid, iprot, oprot):
    args = goToSleepMode_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = goToSleepMode_result()
    try:
      self._handler.goToSleepMode(args.interval)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("goToSleepMode", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_enable_scroll_profling(self, seqid, iprot, oprot):
    args = enable_scroll_profling_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = enable_scroll_profling_result()
    try:
      self._handler.enable_scroll_profling()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("enable_scroll_profling", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_disable_scroll_profling(self, seqid, iprot, oprot):
    args = disable_scroll_profling_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = disable_scroll_profling_result()
    try:
      self._handler.disable_scroll_profling()
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("disable_scroll_profling", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_excute(self, seqid, iprot, oprot):
    args = excute_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = excute_result()
    try:
      self._handler.excute(args.codes)
    except ServerActEx as actionEx:
      result.actionEx = actionEx
    oprot.writeMessageBegin("excute", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class click_textview_by_id_args:
  """
  Attributes:
   - _id
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, _id=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_text_args:
  """
  Attributes:
   - text
   - isVerticalList
   - isScrollable
   - searchFlag
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.STRING, 'searchFlag', None, None, ), # 4
    (5, TType.I32, 'waitForView', None, None, ), # 5
    (6, TType.STRING, 'clickType', None, None, ), # 6
  )

  def __init__(self, text=None, isVerticalList=None, isScrollable=None, searchFlag=None, waitForView=None, clickType=None,):
    self.text = text
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 4)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 5)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 6)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_text_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_text_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_desc_args:
  """
  Attributes:
   - desc
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'desc', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, desc=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self.desc = desc
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_desc_args')
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 1)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_desc_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_desc_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_textview_select_by_text_args:
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_textview_select_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_textview_select_by_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_textview_select_by_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_view_text_by_id_args:
  """
  Attributes:
   - view_type
   - _id
   - isVerticalList
   - isScrollable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_type', None, None, ), # 1
    (2, TType.STRING, '_id', None, None, ), # 2
    (3, TType.I32, 'isVerticalList', None, None, ), # 3
    (4, TType.I32, 'isScrollable', None, None, ), # 4
  )

  def __init__(self, view_type=None, _id=None, isVerticalList=None, isScrollable=None,):
    self.view_type = view_type
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_view_text_by_id_args')
    if self.view_type is not None:
      oprot.writeFieldBegin('view_type', TType.STRING, 1)
      oprot.writeString(self.view_type)
      oprot.writeFieldEnd()
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 2)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 3)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 4)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_view_text_by_id_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_view_text_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_view_text_by_index_args:
  """
  Attributes:
   - view_type
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_type', None, None, ), # 1
    (2, TType.I32, 'index', None, None, ), # 2
  )

  def __init__(self, view_type=None, index=None,):
    self.view_type = view_type
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_view_text_by_index_args')
    if self.view_type is not None:
      oprot.writeFieldBegin('view_type', TType.STRING, 1)
      oprot.writeString(self.view_type)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 2)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_view_text_by_index_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_view_text_by_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_textview_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_textview_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_in_list_by_index_args:
  """
  Attributes:
   - index
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, index=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self.index = index
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_in_list_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_in_list_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_in_list_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_menuitem_by_text_args:
  """
  Attributes:
   - text
   - isVerticalList
   - isScrollable
   - searchFlag
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.STRING, 'searchFlag', None, None, ), # 4
    (5, TType.I32, 'waitForView', None, None, ), # 5
    (6, TType.STRING, 'clickType', None, None, ), # 6
  )

  def __init__(self, text=None, isVerticalList=None, isScrollable=None, searchFlag=None, waitForView=None, clickType=None,):
    self.text = text
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_menuitem_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 4)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 5)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 6)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_menuitem_by_text_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_menuitem_by_text_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_id_args:
  """
  Attributes:
   - _id
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, _id=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_desc_args:
  """
  Attributes:
   - desc
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'desc', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, desc=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self.desc = desc
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_desc_args')
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 1)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_imageview_by_desc_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_imageview_by_desc_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_id_args:
  """
  Attributes:
   - _id
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, _id=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_text_args:
  """
  Attributes:
   - text
   - isVerticalList
   - isScrollable
   - searchFlag
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.STRING, 'searchFlag', None, None, ), # 4
    (5, TType.I32, 'waitForView', None, None, ), # 5
    (6, TType.STRING, 'clickType', None, None, ), # 6
  )

  def __init__(self, text=None, isVerticalList=None, isScrollable=None, searchFlag=None, waitForView=None, clickType=None,):
    self.text = text
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 4)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 5)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 6)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_button_by_text_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_button_by_text_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_checkbox_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_checkbox_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_checkbox_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_checkbox_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_checkbox_by_id_args:
  """
  Attributes:
   - _id
   - isVerticalList
   - isScrollable
   - waitForView
   - clickType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'waitForView', None, None, ), # 4
    (5, TType.STRING, 'clickType', None, None, ), # 5
  )

  def __init__(self, _id=None, isVerticalList=None, isScrollable=None, waitForView=None, clickType=None,):
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.waitForView = waitForView
    self.clickType = clickType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.waitForView = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clickType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_checkbox_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.waitForView is not None:
      oprot.writeFieldBegin('waitForView', TType.I32, 4)
      oprot.writeI32(self.waitForView)
      oprot.writeFieldEnd()
    if self.clickType is not None:
      oprot.writeFieldBegin('clickType', TType.STRING, 5)
      oprot.writeString(self.clickType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_checkbox_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_checkbox_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_view_by_container_id_args:
  """
  Attributes:
   - _id
   - className
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.STRING, 'className', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
  )

  def __init__(self, _id=None, className=None, index=None,):
    self._id = _id
    self.className = className
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_view_by_container_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 2)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_view_by_container_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_view_by_container_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_view_by_container_desc_args:
  """
  Attributes:
   - desc
   - className
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'desc', None, None, ), # 1
    (2, TType.STRING, 'className', None, None, ), # 2
    (3, TType.I32, 'index', None, None, ), # 3
  )

  def __init__(self, desc=None, className=None, index=None,):
    self.desc = desc
    self.className = className
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_view_by_container_desc_args')
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 1)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 2)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 3)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class click_view_by_container_desc_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('click_view_by_container_desc_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class long_click_args:
  """
  Attributes:
   - x
   - y
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'x', None, None, ), # 1
    (2, TType.I32, 'y', None, None, ), # 2
  )

  def __init__(self, x=None, y=None,):
    self.x = x
    self.y = y

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.x = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.y = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('long_click_args')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I32, 1)
      oprot.writeI32(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I32, 2)
      oprot.writeI32(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class long_click_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('long_click_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class double_click_args:
  """
  Attributes:
   - x
   - y
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'x', None, None, ), # 1
    (2, TType.I32, 'y', None, None, ), # 2
  )

  def __init__(self, x=None, y=None,):
    self.x = x
    self.y = y

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.x = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.y = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('double_click_args')
    if self.x is not None:
      oprot.writeFieldBegin('x', TType.I32, 1)
      oprot.writeI32(self.x)
      oprot.writeFieldEnd()
    if self.y is not None:
      oprot.writeFieldBegin('y', TType.I32, 2)
      oprot.writeI32(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class double_click_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('double_click_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_key_args:
  """
  Attributes:
   - key
   - keyType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'key', None, None, ), # 1
    (2, TType.STRING, 'keyType', None, None, ), # 2
  )

  def __init__(self, key=None, keyType=None,):
    self.key = key
    self.keyType = keyType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.keyType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_key_args')
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.keyType is not None:
      oprot.writeFieldBegin('keyType', TType.STRING, 2)
      oprot.writeString(self.keyType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class send_key_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('send_key_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drag_by_param_args:
  """
  Attributes:
   - startX
   - startY
   - endX
   - endY
   - stepCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'startX', None, None, ), # 1
    (2, TType.I32, 'startY', None, None, ), # 2
    (3, TType.I32, 'endX', None, None, ), # 3
    (4, TType.I32, 'endY', None, None, ), # 4
    (5, TType.I32, 'stepCount', None, None, ), # 5
  )

  def __init__(self, startX=None, startY=None, endX=None, endY=None, stepCount=None,):
    self.startX = startX
    self.startY = startY
    self.endX = endX
    self.endY = endY
    self.stepCount = stepCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.startX = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.startY = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.endX = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.endY = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.stepCount = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drag_by_param_args')
    if self.startX is not None:
      oprot.writeFieldBegin('startX', TType.I32, 1)
      oprot.writeI32(self.startX)
      oprot.writeFieldEnd()
    if self.startY is not None:
      oprot.writeFieldBegin('startY', TType.I32, 2)
      oprot.writeI32(self.startY)
      oprot.writeFieldEnd()
    if self.endX is not None:
      oprot.writeFieldBegin('endX', TType.I32, 3)
      oprot.writeI32(self.endX)
      oprot.writeFieldEnd()
    if self.endY is not None:
      oprot.writeFieldBegin('endY', TType.I32, 4)
      oprot.writeI32(self.endY)
      oprot.writeFieldEnd()
    if self.stepCount is not None:
      oprot.writeFieldBegin('stepCount', TType.I32, 5)
      oprot.writeI32(self.stepCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class drag_by_param_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('drag_by_param_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_up_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_up_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_up_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_up_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_down_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_down_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_down_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_down_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_to_bottom_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_to_bottom_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_to_bottom_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_to_bottom_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_to_top_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_to_top_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class scroll_to_top_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('scroll_to_top_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_by_id_args:
  """
  Attributes:
   - _id
   - value
   - isVerticalList
   - isScrollable
   - isClear
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
    (3, TType.I32, 'isVerticalList', None, None, ), # 3
    (4, TType.I32, 'isScrollable', None, None, ), # 4
    (5, TType.I32, 'isClear', None, None, ), # 5
  )

  def __init__(self, _id=None, value=None, isVerticalList=None, isScrollable=None, isClear=None,):
    self._id = _id
    self.value = value
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.isClear = isClear

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.isClear = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 3)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 4)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.isClear is not None:
      oprot.writeFieldBegin('isClear', TType.I32, 5)
      oprot.writeI32(self.isClear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_by_index_args:
  """
  Attributes:
   - index
   - value
   - isVerticalList
   - isScrollable
   - isClear
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
    (3, TType.I32, 'isVerticalList', None, None, ), # 3
    (4, TType.I32, 'isScrollable', None, None, ), # 4
    (5, TType.I32, 'isClear', None, None, ), # 5
  )

  def __init__(self, index=None, value=None, isVerticalList=None, isScrollable=None, isClear=None,):
    self.index = index
    self.value = value
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.isClear = isClear

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.isClear = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 3)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 4)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.isClear is not None:
      oprot.writeFieldBegin('isClear', TType.I32, 5)
      oprot.writeI32(self.isClear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_on_focused_args:
  """
  Attributes:
   - value
   - isVerticalList
   - isScrollable
   - isClear
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'value', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.I32, 'isClear', None, None, ), # 4
  )

  def __init__(self, value=None, isVerticalList=None, isScrollable=None, isClear=None,):
    self.value = value
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.isClear = isClear

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isClear = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_on_focused_args')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 1)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.isClear is not None:
      oprot.writeFieldBegin('isClear', TType.I32, 4)
      oprot.writeI32(self.isClear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class entertext_edittext_on_focused_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('entertext_edittext_on_focused_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_by_id_args:
  """
  Attributes:
   - _id
   - isVerticalList
   - isScrollable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
  )

  def __init__(self, _id=None, isVerticalList=None, isScrollable=None,):
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_by_id_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_by_id_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_by_index_args:
  """
  Attributes:
   - index
   - isVerticalList
   - isScrollable
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
  )

  def __init__(self, index=None, isVerticalList=None, isScrollable=None,):
    self.index = index
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_on_focused_args:
  """
  Attributes:
   - isVerticalList
   - isScrollable
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'isVerticalList', None, None, ), # 1
    (2, TType.I32, 'isScrollable', None, None, ), # 2
  )

  def __init__(self, isVerticalList=None, isScrollable=None,):
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_on_focused_args')
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 1)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 2)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clear_edittext_on_focused_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clear_edittext_on_focused_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goback_args:
  """
  Attributes:
   - className
   - idType
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'className', None, None, ), # 1
    (2, TType.STRING, 'idType', None, None, ), # 2
    (3, TType.STRING, 'id', None, None, ), # 3
  )

  def __init__(self, className=None, idType=None, id=None,):
    self.className = className
    self.idType = idType
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.idType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goback_args')
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 1)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.idType is not None:
      oprot.writeFieldBegin('idType', TType.STRING, 2)
      oprot.writeString(self.idType)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 3)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goback_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goback_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class shutdown_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('shutdown_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_text_args:
  """
  Attributes:
   - text
   - isVerticalList
   - isScrollable
   - searchFlag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'isVerticalList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.STRING, 'searchFlag', None, None, ), # 4
  )

  def __init__(self, text=None, isVerticalList=None, isScrollable=None, searchFlag=None,):
    self.text = text
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 2)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 4)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_text_args:
  """
  Attributes:
   - text
   - isVerticaList
   - isScrollable
   - searchFlag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
    (2, TType.I32, 'isVerticaList', None, None, ), # 2
    (3, TType.I32, 'isScrollable', None, None, ), # 3
    (4, TType.STRING, 'searchFlag', None, None, ), # 4
  )

  def __init__(self, text=None, isVerticaList=None, isScrollable=None, searchFlag=None,):
    self.text = text
    self.isVerticaList = isVerticaList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.isVerticaList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticaList is not None:
      oprot.writeFieldBegin('isVerticaList', TType.I32, 2)
      oprot.writeI32(self.isVerticaList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 3)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 4)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_webview_title_args:
  """
  Attributes:
   - title
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'title', None, None, ), # 1
  )

  def __init__(self, title=None,):
    self.title = title

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.title = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_webview_title_args')
    if self.title is not None:
      oprot.writeFieldBegin('title', TType.STRING, 1)
      oprot.writeString(self.title)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_webview_title_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_webview_title_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_checkbox_checked_by_text_args:
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_checkbox_checked_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_checkbox_checked_by_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_checkbox_checked_by_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_checkbox_checked_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_checkbox_checked_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_checkbox_checked_by_index_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_checkbox_checked_by_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_togglebutton_checked_by_text_args:
  """
  Attributes:
   - text
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'text', None, None, ), # 1
  )

  def __init__(self, text=None,):
    self.text = text

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_togglebutton_checked_by_text_args')
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 1)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_togglebutton_checked_by_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_togglebutton_checked_by_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_togglebutton_checked_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_togglebutton_checked_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_togglebutton_checked_by_index_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_togglebutton_checked_by_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_compoundbutton_checked_by_index_args:
  """
  Attributes:
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
  )

  def __init__(self, index=None,):
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_compoundbutton_checked_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_compoundbutton_checked_by_index_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_compoundbutton_checked_by_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_id_args:
  """
  Attributes:
   - view_type
   - _id
   - isVerticalList
   - isScrollable
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_type', None, None, ), # 1
    (2, TType.STRING, '_id', None, None, ), # 2
    (3, TType.I32, 'isVerticalList', None, None, ), # 3
    (4, TType.I32, 'isScrollable', None, None, ), # 4
  )

  def __init__(self, view_type=None, _id=None, isVerticalList=None, isScrollable=None,):
    self.view_type = view_type
    self._id = _id
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_id_args')
    if self.view_type is not None:
      oprot.writeFieldBegin('view_type', TType.STRING, 1)
      oprot.writeString(self.view_type)
      oprot.writeFieldEnd()
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 2)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 3)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 4)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_id_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_text_args:
  """
  Attributes:
   - view_type
   - text
   - isVerticalList
   - isScrollable
   - searchFlag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_type', None, None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.I32, 'isVerticalList', None, None, ), # 3
    (4, TType.I32, 'isScrollable', None, None, ), # 4
    (5, TType.STRING, 'searchFlag', None, None, ), # 5
  )

  def __init__(self, view_type=None, text=None, isVerticalList=None, isScrollable=None, searchFlag=None,):
    self.view_type = view_type
    self.text = text
    self.isVerticalList = isVerticalList
    self.isScrollable = isScrollable
    self.searchFlag = searchFlag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.isVerticalList = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.isScrollable = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.searchFlag = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_text_args')
    if self.view_type is not None:
      oprot.writeFieldBegin('view_type', TType.STRING, 1)
      oprot.writeString(self.view_type)
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text)
      oprot.writeFieldEnd()
    if self.isVerticalList is not None:
      oprot.writeFieldBegin('isVerticalList', TType.I32, 3)
      oprot.writeI32(self.isVerticalList)
      oprot.writeFieldEnd()
    if self.isScrollable is not None:
      oprot.writeFieldBegin('isScrollable', TType.I32, 4)
      oprot.writeI32(self.isScrollable)
      oprot.writeFieldEnd()
    if self.searchFlag is not None:
      oprot.writeFieldBegin('searchFlag', TType.STRING, 5)
      oprot.writeString(self.searchFlag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_text_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_text_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_index_args:
  """
  Attributes:
   - view_type
   - index
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'view_type', None, None, ), # 1
    (2, TType.I32, 'index', None, None, ), # 2
  )

  def __init__(self, view_type=None, index=None,):
    self.view_type = view_type
    self.index = index

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.view_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_index_args')
    if self.view_type is not None:
      oprot.writeFieldBegin('view_type', TType.STRING, 1)
      oprot.writeString(self.view_type)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 2)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_view_enabled_by_index_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_view_enabled_by_index_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_progressbar_by_index_args:
  """
  Attributes:
   - index
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'index', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, index=None, value=None,):
    self.index = index
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_progressbar_by_index_args')
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 1)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class set_progressbar_by_index_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('set_progressbar_by_index_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_view_by_id_args:
  """
  Attributes:
   - _id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, '_id', None, None, ), # 1
  )

  def __init__(self, _id=None,):
    self._id = _id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self._id = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_view_by_id_args')
    if self._id is not None:
      oprot.writeFieldBegin('_id', TType.STRING, 1)
      oprot.writeString(self._id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_view_by_id_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_view_by_id_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_view_by_desc_args:
  """
  Attributes:
   - desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'desc', None, None, ), # 1
  )

  def __init__(self, desc=None,):
    self.desc = desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.desc = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_view_by_desc_args')
    if self.desc is not None:
      oprot.writeFieldBegin('desc', TType.STRING, 1)
      oprot.writeString(self.desc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class search_view_by_desc_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('search_view_by_desc_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_external_storage_enable_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_external_storage_enable_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class is_external_storage_enable_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('is_external_storage_enable_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_system_language_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_system_language_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_system_language_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_system_language_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_activity_name_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_activity_name_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_activity_name_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_activity_name_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_update_watcher_args:
  """
  Attributes:
   - appName
   - className
   - idType
   - id
   - action
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appName', None, None, ), # 1
    (2, TType.STRING, 'className', None, None, ), # 2
    (3, TType.STRING, 'idType', None, None, ), # 3
    (4, TType.STRING, 'id', None, None, ), # 4
    (5, TType.STRING, 'action', None, None, ), # 5
  )

  def __init__(self, appName=None, className=None, idType=None, id=None, action=None,):
    self.appName = appName
    self.className = className
    self.idType = idType
    self.id = id
    self.action = action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.className = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.action = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_update_watcher_args')
    if self.appName is not None:
      oprot.writeFieldBegin('appName', TType.STRING, 1)
      oprot.writeString(self.appName)
      oprot.writeFieldEnd()
    if self.className is not None:
      oprot.writeFieldBegin('className', TType.STRING, 2)
      oprot.writeString(self.className)
      oprot.writeFieldEnd()
    if self.idType is not None:
      oprot.writeFieldBegin('idType', TType.STRING, 3)
      oprot.writeString(self.idType)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 4)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRING, 5)
      oprot.writeString(self.action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_update_watcher_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_update_watcher_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_condition_action_watcher_args:
  """
  Attributes:
   - packageName_condition
   - className_condition
   - idType_condition
   - id_condition
   - action
   - className_action
   - idType_action
   - id_action
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'packageName_condition', None, None, ), # 1
    (2, TType.STRING, 'className_condition', None, None, ), # 2
    (3, TType.STRING, 'idType_condition', None, None, ), # 3
    (4, TType.STRING, 'id_condition', None, None, ), # 4
    (5, TType.STRING, 'action', None, None, ), # 5
    (6, TType.STRING, 'className_action', None, None, ), # 6
    (7, TType.STRING, 'idType_action', None, None, ), # 7
    (8, TType.STRING, 'id_action', None, None, ), # 8
  )

  def __init__(self, packageName_condition=None, className_condition=None, idType_condition=None, id_condition=None, action=None, className_action=None, idType_action=None, id_action=None,):
    self.packageName_condition = packageName_condition
    self.className_condition = className_condition
    self.idType_condition = idType_condition
    self.id_condition = id_condition
    self.action = action
    self.className_action = className_action
    self.idType_action = idType_action
    self.id_action = id_action

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.packageName_condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.className_condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.idType_condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.id_condition = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.className_action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.idType_action = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.id_action = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_condition_action_watcher_args')
    if self.packageName_condition is not None:
      oprot.writeFieldBegin('packageName_condition', TType.STRING, 1)
      oprot.writeString(self.packageName_condition)
      oprot.writeFieldEnd()
    if self.className_condition is not None:
      oprot.writeFieldBegin('className_condition', TType.STRING, 2)
      oprot.writeString(self.className_condition)
      oprot.writeFieldEnd()
    if self.idType_condition is not None:
      oprot.writeFieldBegin('idType_condition', TType.STRING, 3)
      oprot.writeString(self.idType_condition)
      oprot.writeFieldEnd()
    if self.id_condition is not None:
      oprot.writeFieldBegin('id_condition', TType.STRING, 4)
      oprot.writeString(self.id_condition)
      oprot.writeFieldEnd()
    if self.action is not None:
      oprot.writeFieldBegin('action', TType.STRING, 5)
      oprot.writeString(self.action)
      oprot.writeFieldEnd()
    if self.className_action is not None:
      oprot.writeFieldBegin('className_action', TType.STRING, 6)
      oprot.writeString(self.className_action)
      oprot.writeFieldEnd()
    if self.idType_action is not None:
      oprot.writeFieldBegin('idType_action', TType.STRING, 7)
      oprot.writeString(self.idType_action)
      oprot.writeFieldEnd()
    if self.id_action is not None:
      oprot.writeFieldBegin('id_action', TType.STRING, 8)
      oprot.writeString(self.id_action)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class register_condition_action_watcher_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('register_condition_action_watcher_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregister_update_watcher_args:
  """
  Attributes:
   - appName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'appName', None, None, ), # 1
  )

  def __init__(self, appName=None,):
    self.appName = appName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.appName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregister_update_watcher_args')
    if self.appName is not None:
      oprot.writeFieldBegin('appName', TType.STRING, 1)
      oprot.writeString(self.appName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class unregister_update_watcher_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('unregister_update_watcher_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class zoom_by_param_args:
  """
  Attributes:
   - mode
   - startX1
   - startY1
   - startX2
   - startY2
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'mode', None, None, ), # 1
    (2, TType.I32, 'startX1', None, None, ), # 2
    (3, TType.I32, 'startY1', None, None, ), # 3
    (4, TType.I32, 'startX2', None, None, ), # 4
    (5, TType.I32, 'startY2', None, None, ), # 5
  )

  def __init__(self, mode=None, startX1=None, startY1=None, startX2=None, startY2=None,):
    self.mode = mode
    self.startX1 = startX1
    self.startY1 = startY1
    self.startX2 = startX2
    self.startY2 = startY2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.mode = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.startX1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.startY1 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.startX2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.startY2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('zoom_by_param_args')
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.STRING, 1)
      oprot.writeString(self.mode)
      oprot.writeFieldEnd()
    if self.startX1 is not None:
      oprot.writeFieldBegin('startX1', TType.I32, 2)
      oprot.writeI32(self.startX1)
      oprot.writeFieldEnd()
    if self.startY1 is not None:
      oprot.writeFieldBegin('startY1', TType.I32, 3)
      oprot.writeI32(self.startY1)
      oprot.writeFieldEnd()
    if self.startX2 is not None:
      oprot.writeFieldBegin('startX2', TType.I32, 4)
      oprot.writeI32(self.startX2)
      oprot.writeFieldEnd()
    if self.startY2 is not None:
      oprot.writeFieldBegin('startY2', TType.I32, 5)
      oprot.writeI32(self.startY2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class zoom_by_param_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('zoom_by_param_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDisplayWidth_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDisplayWidth_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDisplayWidth_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDisplayWidth_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDisplayHeight_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDisplayHeight_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDisplayHeight_result:
  """
  Attributes:
   - success
   - actionEx
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, actionEx=None,):
    self.success = success
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDisplayHeight_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goToSleepMode_args:
  """
  Attributes:
   - interval
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'interval', None, None, ), # 1
  )

  def __init__(self, interval=None,):
    self.interval = interval

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.interval = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goToSleepMode_args')
    if self.interval is not None:
      oprot.writeFieldBegin('interval', TType.I32, 1)
      oprot.writeI32(self.interval)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class goToSleepMode_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('goToSleepMode_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class enable_scroll_profling_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('enable_scroll_profling_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class enable_scroll_profling_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('enable_scroll_profling_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_scroll_profling_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_scroll_profling_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_scroll_profling_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_scroll_profling_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class excute_args:
  """
  Attributes:
   - codes
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'codes', None, None, ), # 1
  )

  def __init__(self, codes=None,):
    self.codes = codes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.codes = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('excute_args')
    if self.codes is not None:
      oprot.writeFieldBegin('codes', TType.STRING, 1)
      oprot.writeString(self.codes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class excute_result:
  """
  Attributes:
   - actionEx
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'actionEx', (ServerActEx, ServerActEx.thrift_spec), None, ), # 1
  )

  def __init__(self, actionEx=None,):
    self.actionEx = actionEx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.actionEx = ServerActEx()
          self.actionEx.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('excute_result')
    if self.actionEx is not None:
      oprot.writeFieldBegin('actionEx', TType.STRUCT, 1)
      self.actionEx.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
